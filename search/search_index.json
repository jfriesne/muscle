{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MUSCLE by Example For the latest MUSCLE source code, full Doxygen AutoDocs, and other MUSCLE documentation, visit the MUSCLE web page . This tour is meant to introduce the reader to the various MUSCLE APIs through simple \"toy\" example programs that demonstrate each class's purpose and common usage-patterns. The examples are ordered in \"bottom-up\" fashion, with the simplest and lowest-level APIs demonstrated first, followed by some higher-level APIs that make use of those first APIs, and so on until we reach the highest-level APIs near the end of the tour. While reading the HTML topics pages (starting at the top), you can also have a Terminal window open, so you can view, compile, and execute the corresponding toy example programs. The MUSCLE toy example programs may be compiled and run under any common desktop OS. Under Linux and MacOS/X, you can compile them by cd 'ing to the muscle/html/muscle-by-example/examples sub-directory (or to any one of the sub-directories underneath it) and typing make . Under Windows, make sure Visual Studio 2015 or higher, is installed, and run the BUILD_ALL.bat file that is located in the muscle\\html\\muscle-by-example\\examples\\vc++14 sub-directory (or, if you prefer to use an IDE, you can double-click on any of the .vcxproj or .sln files in that same folder to launch Visual Studio)","title":"Home"},{"location":"#muscle-by-example","text":"For the latest MUSCLE source code, full Doxygen AutoDocs, and other MUSCLE documentation, visit the MUSCLE web page . This tour is meant to introduce the reader to the various MUSCLE APIs through simple \"toy\" example programs that demonstrate each class's purpose and common usage-patterns. The examples are ordered in \"bottom-up\" fashion, with the simplest and lowest-level APIs demonstrated first, followed by some higher-level APIs that make use of those first APIs, and so on until we reach the highest-level APIs near the end of the tour. While reading the HTML topics pages (starting at the top), you can also have a Terminal window open, so you can view, compile, and execute the corresponding toy example programs. The MUSCLE toy example programs may be compiled and run under any common desktop OS. Under Linux and MacOS/X, you can compile them by cd 'ing to the muscle/html/muscle-by-example/examples sub-directory (or to any one of the sub-directories underneath it) and typing make . Under Windows, make sure Visual Studio 2015 or higher, is installed, and run the BUILD_ALL.bat file that is located in the muscle\\html\\muscle-by-example\\examples\\vc++14 sub-directory (or, if you prefer to use an IDE, you can double-click on any of the .vcxproj or .sln files in that same folder to launch Visual Studio)","title":"MUSCLE by Example"},{"location":"abstractmessageiogateway/","text":"muscle::AbstractMessageIOGateway class (API) #include \"iogateway/AbstractMessageIOGateway.h\" An AbstractMessageIOGateway is a semi-abstract interface for defining a mid-level protocol-serialization/deserialization object. A gateway has just two jobs: The first job is to receive a stream of incoming bytes from its DataIO object and parse them to create Message objects to pass up to its owner. The second job is to receive a series of Message objects from its owner and convert them into a stream of outgoing bytes to pass down to its DataIO object. Gateways are typically used in conjunction with AbstractReflectSession objects in a ReflectServer . They handle the session object's communication with its client device. The specific rules of how to convert bytes to Message objects (and vice-versa) are left up to the subclass. The most common subclass to use is the MessageIOGateway , which flattens and transmits arbitrary Message objects using MUSCLE's own binary-flattened-Message protocol. PlainTextMessageIOGateway is a more specialized gateway that converts plain ASCII text into Message objects that contain that text in a string field (and vice versa), encoding one line of text into each String value. RawDataMessageIOGateway simply shovels the incoming raw bytes into a raw-data field of a Message object, for the high-level user to deal with verbatim. No message-framing is attempted. SLIPFramedDataMessageIOGateway is similar to RawDataMessageIOGateway , but it uses the framing rules of the SLIP protocol to partition the incoming byte-stream into appropriate-sized chunks. etc Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/iogateway (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: iogateway/example_1_message_to_file.cpp iogateway/example_2_message_to_tcp.cpp iogateway/example_3_text_to_file.cpp iogateway/example_4_text_to_tcp.cpp","title":"AbstractMessageIOGateway"},{"location":"abstractmessageiogateway/#muscleabstractmessageiogateway-class-api","text":"#include \"iogateway/AbstractMessageIOGateway.h\" An AbstractMessageIOGateway is a semi-abstract interface for defining a mid-level protocol-serialization/deserialization object. A gateway has just two jobs: The first job is to receive a stream of incoming bytes from its DataIO object and parse them to create Message objects to pass up to its owner. The second job is to receive a series of Message objects from its owner and convert them into a stream of outgoing bytes to pass down to its DataIO object. Gateways are typically used in conjunction with AbstractReflectSession objects in a ReflectServer . They handle the session object's communication with its client device. The specific rules of how to convert bytes to Message objects (and vice-versa) are left up to the subclass. The most common subclass to use is the MessageIOGateway , which flattens and transmits arbitrary Message objects using MUSCLE's own binary-flattened-Message protocol. PlainTextMessageIOGateway is a more specialized gateway that converts plain ASCII text into Message objects that contain that text in a string field (and vice versa), encoding one line of text into each String value. RawDataMessageIOGateway simply shovels the incoming raw bytes into a raw-data field of a Message object, for the high-level user to deal with verbatim. No message-framing is attempted. SLIPFramedDataMessageIOGateway is similar to RawDataMessageIOGateway , but it uses the framing rules of the SLIP protocol to partition the incoming byte-stream into appropriate-sized chunks. etc Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/iogateway (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: iogateway/example_1_message_to_file.cpp iogateway/example_2_message_to_tcp.cpp iogateway/example_3_text_to_file.cpp iogateway/example_4_text_to_tcp.cpp","title":"muscle::AbstractMessageIOGateway class (API)"},{"location":"abstractreflectsession/","text":"muscle::AbstractReflectSession class (API) #include \"reflector/AbstractReflectSession.h\" AbstractReflectSession is an abstract base class for any object that wants to handle the needs of a single file descriptor in the ReflectServer 's event loop. Each session object holds an I/O gateway (via an AbstractMessageIOGatewayRef ) which it uses to convert incoming bytes from its socket/file-descriptor to Messages (and vice versa). This gateway can be manually installed (via SetGateway() ), or if not, a default gateway object will be automatically created by calling the session object's CreateGateway() method. When the session is first attached to the ReflectServer , the session's AttachedToServer() method will be called. In this method the session can do any setup/initialization work it wants to do, now that it has access to the ReflectServer 's resources. Each Message generated by the gateway object's parser (in response to incoming data) is passed to the session via a call to the session's MessageReceivedFromGateway() method (which must be implemented by the session subclass) When a Message is handed over to the session by one of the other sessions living on the same ReflectServer , MessageReceivedFromSession() will be called. When the session wants to send a Message back to its own client (via the gateway), it can call AddOutgoingMessage()) to do so. When the session's TCP connection is closed (e.g. the client-software associated wih this session has quit or disconnected), the method's ClientConnectionClosed() method is called. The default implementation of this method returns true, indicating that the session object should be detached from the server and destroyed ASAP. If the session wants to commit suicide, it can call EndSession() on itself and it will be detached and destroyed ASAP. Just before the session is detached from the ReflectServer , its AboutToDetachFromServer() method will be called. This gives the session a final chance to say its goodbyes, while it still has access to the ReflectServer 's resources. Included concrete subclasses include DumbReflectSession (which simply forwards incoming Messages from the session's gateway to all other connected sessions) and StorageReflectSession (which implements the full MUSCLE node-tree-storage and regex-based forwarding logic as described here ) Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/reflector (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: reflector/example_1_dumb_server.cpp reflector/example_2_dumb_client.cpp reflector/example_3_annotated_dumb_server.cpp reflector/example_4_smart_server.cpp reflector/example_5_smart_client.cpp reflector/example_6_smart_server_with_pulsenode.cpp reflector/example_7_smart_server_with_udp_pingpong.cpp","title":"AbstractReflectSession"},{"location":"abstractreflectsession/#muscleabstractreflectsession-class-api","text":"#include \"reflector/AbstractReflectSession.h\" AbstractReflectSession is an abstract base class for any object that wants to handle the needs of a single file descriptor in the ReflectServer 's event loop. Each session object holds an I/O gateway (via an AbstractMessageIOGatewayRef ) which it uses to convert incoming bytes from its socket/file-descriptor to Messages (and vice versa). This gateway can be manually installed (via SetGateway() ), or if not, a default gateway object will be automatically created by calling the session object's CreateGateway() method. When the session is first attached to the ReflectServer , the session's AttachedToServer() method will be called. In this method the session can do any setup/initialization work it wants to do, now that it has access to the ReflectServer 's resources. Each Message generated by the gateway object's parser (in response to incoming data) is passed to the session via a call to the session's MessageReceivedFromGateway() method (which must be implemented by the session subclass) When a Message is handed over to the session by one of the other sessions living on the same ReflectServer , MessageReceivedFromSession() will be called. When the session wants to send a Message back to its own client (via the gateway), it can call AddOutgoingMessage()) to do so. When the session's TCP connection is closed (e.g. the client-software associated wih this session has quit or disconnected), the method's ClientConnectionClosed() method is called. The default implementation of this method returns true, indicating that the session object should be detached from the server and destroyed ASAP. If the session wants to commit suicide, it can call EndSession() on itself and it will be detached and destroyed ASAP. Just before the session is detached from the ReflectServer , its AboutToDetachFromServer() method will be called. This gives the session a final chance to say its goodbyes, while it still has access to the ReflectServer 's resources. Included concrete subclasses include DumbReflectSession (which simply forwards incoming Messages from the session's gateway to all other connected sessions) and StorageReflectSession (which implements the full MUSCLE node-tree-storage and regex-based forwarding logic as described here ) Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/reflector (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: reflector/example_1_dumb_server.cpp reflector/example_2_dumb_client.cpp reflector/example_3_annotated_dumb_server.cpp reflector/example_4_smart_server.cpp reflector/example_5_smart_client.cpp reflector/example_6_smart_server_with_pulsenode.cpp reflector/example_7_smart_server_with_udp_pingpong.cpp","title":"muscle::AbstractReflectSession class (API)"},{"location":"abstractsessioniopolicy/","text":"muscle::AbstractSessionIOPolicy class (API) #include \"reflector/AbstractSessionIOPolicy.h\" AbstractSessionIOPolicy is an abstract base class for an object that can be used to limit the amount of data the sessions of a ReflectServer can send/receive on any given iteration of the ServerProcessLoop() event-loop. Use of I/O policies is 100% optional -- by default (i.e. with no policies installed) the ReflectServer will just perform all the necessary I/O as quickly as possible, which is usually what you want. The most commonly used I/O policy is the RateLimitSessionIOPolicy , which allows you to control the network bandwidth used by the server. You can install a different AbstractSessionIOPolicy on each session object if you want, or have multiple (or even all) session objects share the same AbstractSessionIOPolicy object. Specify an I/O policy for a session's input data-stream by calling AbstractReflectSession::SetInputPolicy() Specify an I/O policy for a session's output data-stream by calling AbstractReflectSession::SetOutputPolicy() Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/reflector (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file)","title":"AbstractSessionIOPolicy"},{"location":"abstractsessioniopolicy/#muscleabstractsessioniopolicy-class-api","text":"#include \"reflector/AbstractSessionIOPolicy.h\" AbstractSessionIOPolicy is an abstract base class for an object that can be used to limit the amount of data the sessions of a ReflectServer can send/receive on any given iteration of the ServerProcessLoop() event-loop. Use of I/O policies is 100% optional -- by default (i.e. with no policies installed) the ReflectServer will just perform all the necessary I/O as quickly as possible, which is usually what you want. The most commonly used I/O policy is the RateLimitSessionIOPolicy , which allows you to control the network bandwidth used by the server. You can install a different AbstractSessionIOPolicy on each session object if you want, or have multiple (or even all) session objects share the same AbstractSessionIOPolicy object. Specify an I/O policy for a session's input data-stream by calling AbstractReflectSession::SetInputPolicy() Specify an I/O policy for a session's output data-stream by calling AbstractReflectSession::SetOutputPolicy() Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/reflector (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file)","title":"muscle::AbstractSessionIOPolicy class (API)"},{"location":"atomiccounter/","text":"muscle::AtomicCounter class (API) #include \"system/AtomicCounter.h\" A Thread-safe, lockless int32-counter Similar to: std::atomic<int32> , InterlockedIncrement() / InterlockedDecrement() Used primarily by the Ref / RefCountable classes for implementing thread-safe shared pointers Constructor initializes the counter to zero AtomicIncrement() does an atomic-increment of the counter value, and returns true iff the counter's post-increment value is 1. AtomicDecrement() does an atomic-decrement of the counter value, and returns true iff the counter's post-decrement value is 0. Compiles down to a non-atomic/plain-int32 counter if -DMUSCLE_SINGLE_THREAD_ONLY is defined (i.e. if multithreading support is disabled) Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/atomiccounter (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: atomiccounter/example_1_basic_usage.cpp atomiccounter/example_2_stress_test.cpp","title":"AtomicCounter"},{"location":"atomiccounter/#muscleatomiccounter-class-api","text":"#include \"system/AtomicCounter.h\" A Thread-safe, lockless int32-counter Similar to: std::atomic<int32> , InterlockedIncrement() / InterlockedDecrement() Used primarily by the Ref / RefCountable classes for implementing thread-safe shared pointers Constructor initializes the counter to zero AtomicIncrement() does an atomic-increment of the counter value, and returns true iff the counter's post-increment value is 1. AtomicDecrement() does an atomic-decrement of the counter value, and returns true iff the counter's post-decrement value is 0. Compiles down to a non-atomic/plain-int32 counter if -DMUSCLE_SINGLE_THREAD_ONLY is defined (i.e. if multithreading support is disabled) Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/atomiccounter (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: atomiccounter/example_1_basic_usage.cpp atomiccounter/example_2_stress_test.cpp","title":"muscle::AtomicCounter class (API)"},{"location":"bitchord/","text":"muscle::BitChord class (API) #include \"support/BitChord.h\" This templated class holds a fixed-size ordered set of boolean bits (packed into 32-bit words), for easy storage and manipulation of an N-bit boolean vector. Designed as a more-strongly-typed, less-error-prone replacement for C-style direct bit-manipulation operations No limitation on how many bits can be stored Implements the PseudoFlattenable interface for easy serialization. Particularly useful in conjunction with an enumeration of flag-names (e.g. enum {BIT_A=0, BIT_B, BIT_C, NUM_BITS}; DECLARE_BITCHORD_FLAGS_TYPE(MyBits, NUM_BITS);} ) e.g. instead of uint32 bits = (1<<BIT_A)|(1<<BIT_C); you could declare MyBits bits(BIT_A, BIT_C); instead of bool isBSet = (bits & (1<<BIT_B)) != 0; you could test with bool isBSet = bits.IsBitSet(BIT_C); Declares many other convenient methods like SetBit() , ClearBit() , ToggleBit() , AreAnyBitsSet() , etc. Methods and constructors using variadic arguments work under both C++11 (using C++11 variadic templates) and C++03 (using a fallback macro-based implementation)","title":"BitChord"},{"location":"bitchord/#musclebitchord-class-api","text":"#include \"support/BitChord.h\" This templated class holds a fixed-size ordered set of boolean bits (packed into 32-bit words), for easy storage and manipulation of an N-bit boolean vector. Designed as a more-strongly-typed, less-error-prone replacement for C-style direct bit-manipulation operations No limitation on how many bits can be stored Implements the PseudoFlattenable interface for easy serialization. Particularly useful in conjunction with an enumeration of flag-names (e.g. enum {BIT_A=0, BIT_B, BIT_C, NUM_BITS}; DECLARE_BITCHORD_FLAGS_TYPE(MyBits, NUM_BITS);} ) e.g. instead of uint32 bits = (1<<BIT_A)|(1<<BIT_C); you could declare MyBits bits(BIT_A, BIT_C); instead of bool isBSet = (bits & (1<<BIT_B)) != 0; you could test with bool isBSet = bits.IsBitSet(BIT_C); Declares many other convenient methods like SetBit() , ClearBit() , ToggleBit() , AreAnyBitsSet() , etc. Methods and constructors using variadic arguments work under both C++11 (using C++11 variadic templates) and C++03 (using a fallback macro-based implementation)","title":"muscle::BitChord class (API)"},{"location":"bytebuffer/","text":"muscle::ByteBuffer class (API) #include \"util/ByteBuffer.h\" A ByteBuffer holds a variable-sized array of raw unsigned bytes. Similar to the String class, except instead of a 0-terminated string, it holds raw binary data. Similar to: QByteBuffer , std::vector<uint8_t> Holds up to (2^32) bytes Has convenience methods for writing/reading/appending int32 / float / String /etc values of varying lengths, with specified endian-ness ByteBuffer inherits FlatCountable for efficient passing around of large binary blobs O(1) SwapContents() Idiom: ByteBufferRef s are often allocated using GetByteBufferFromPool() Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/bytebuffer (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: bytebuffer/example_1_basic_usage.cpp bytebuffer/example_2_bb_pool.cpp bytebuffer/example_3_endian.cpp dataio/example_4_idioms.cpp zlibcodec/example_1_basic_usage.cpp zlibutilityfunctions/example_1_byte_buffers.cpp","title":"ByteBuffer"},{"location":"bytebuffer/#musclebytebuffer-class-api","text":"#include \"util/ByteBuffer.h\" A ByteBuffer holds a variable-sized array of raw unsigned bytes. Similar to the String class, except instead of a 0-terminated string, it holds raw binary data. Similar to: QByteBuffer , std::vector<uint8_t> Holds up to (2^32) bytes Has convenience methods for writing/reading/appending int32 / float / String /etc values of varying lengths, with specified endian-ness ByteBuffer inherits FlatCountable for efficient passing around of large binary blobs O(1) SwapContents() Idiom: ByteBufferRef s are often allocated using GetByteBufferFromPool() Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/bytebuffer (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: bytebuffer/example_1_basic_usage.cpp bytebuffer/example_2_bb_pool.cpp bytebuffer/example_3_endian.cpp dataio/example_4_idioms.cpp zlibcodec/example_1_basic_usage.cpp zlibutilityfunctions/example_1_byte_buffers.cpp","title":"muscle::ByteBuffer class (API)"},{"location":"bytebufferdataio/","text":"muscle::ByteBufferDataIO class (API) #include \"dataio/ByteBufferDataIO.h\" ByteBufferDataIO can be used to access the memory-contents of a ByteBuffer object as if it were a file. Useful if you have some code that was designed to use a DataIO , but you'd rather not write to disk/network, and you prefer keep the output in RAM (or read the input from RAM) instead. The ByteBuffer will behave much like a file would (i.e. it will be resized larger as you Write() past the end of its current size to append data, etc) Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/dataio (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file)","title":"ByteBufferDataIO"},{"location":"bytebufferdataio/#musclebytebufferdataio-class-api","text":"#include \"dataio/ByteBufferDataIO.h\" ByteBufferDataIO can be used to access the memory-contents of a ByteBuffer object as if it were a file. Useful if you have some code that was designed to use a DataIO , but you'd rather not write to disk/network, and you prefer keep the output in RAM (or read the input from RAM) instead. The ByteBuffer will behave much like a file would (i.e. it will be resized larger as you Write() past the end of its current size to append data, etc) Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/dataio (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file)","title":"muscle::ByteBufferDataIO class (API)"},{"location":"childprocessdataio/","text":"muscle::ChildProcessDataIO class (API) #include \"dataio/ChildProcessDataIO.h\" ChildProcessDataIO is used to launch a child process, and then (optionally) communicate with it via its stdin and stdout streams. At some point after creating the ChildProcessDataIO object you'll want to call LaunchChildProcess() on it to actually launch the child process After the child process is launched, Write() sends data to its stdin stream, and Read() reads data from its stdout stream. By default, the ChildProcessDataIO will try to get rid of the child process when the ChildProcessDataIO object is being destroyed. You can modify this behavior by calling SetChildProcessShutdownBehavior() . SignalChildProcess() will send a UNIX-style signal to the child process (not available under Windows) KillChildProcess() will nuke the child process from orbit. WaitForChildProcessToExit() will block until the child process has exited. Some static convenience-methods like System() and LaunchIndependentChildProcess() are declared to let you easily launch \"fire and forget\" child processes without having to create a ChildProcessDataIO object and keep it around. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/dataio (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: dataio/example_6_child_process.cpp","title":"ChildProcessDataIO"},{"location":"childprocessdataio/#musclechildprocessdataio-class-api","text":"#include \"dataio/ChildProcessDataIO.h\" ChildProcessDataIO is used to launch a child process, and then (optionally) communicate with it via its stdin and stdout streams. At some point after creating the ChildProcessDataIO object you'll want to call LaunchChildProcess() on it to actually launch the child process After the child process is launched, Write() sends data to its stdin stream, and Read() reads data from its stdout stream. By default, the ChildProcessDataIO will try to get rid of the child process when the ChildProcessDataIO object is being destroyed. You can modify this behavior by calling SetChildProcessShutdownBehavior() . SignalChildProcess() will send a UNIX-style signal to the child process (not available under Windows) KillChildProcess() will nuke the child process from orbit. WaitForChildProcessToExit() will block until the child process has exited. Some static convenience-methods like System() and LaunchIndependentChildProcess() are declared to let you easily launch \"fire and forget\" child processes without having to create a ChildProcessDataIO object and keep it around. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/dataio (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: dataio/example_6_child_process.cpp","title":"muscle::ChildProcessDataIO class (API)"},{"location":"cpuloadmeter/","text":"muscle::CPULoadMeter class (API) #include \"util/CPULoadMeter.h\" An OS-neutral mechanism for monitoring the CPU-usage of the host computer over time. Tells you the percentage of your computer's CPU power that is in use If GetCPULoad() returns 0.0f, your CPU is completely idle If GetCPULoad() returns 1.0f, all cores on your CPU are pegged If GetCPULoad() returns something in between, your CPU is partially utilized. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/cpuloadmeter (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: cpuloadmeter/example_1_basic_usage.cpp","title":"CPULoadMeter"},{"location":"cpuloadmeter/#musclecpuloadmeter-class-api","text":"#include \"util/CPULoadMeter.h\" An OS-neutral mechanism for monitoring the CPU-usage of the host computer over time. Tells you the percentage of your computer's CPU power that is in use If GetCPULoad() returns 0.0f, your CPU is completely idle If GetCPULoad() returns 1.0f, all cores on your CPU are pegged If GetCPULoad() returns something in between, your CPU is partially utilized. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/cpuloadmeter (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: cpuloadmeter/example_1_basic_usage.cpp","title":"muscle::CPULoadMeter class (API)"},{"location":"dataflattener/","text":"muscle::DataFlattener class (API) #include \"util/DataFlattener.h\" A DataFlattener is a lightweight binary-data-writer object that makes it easy and safe to write/serialize POD data and Flattenable / PseudoFlattenable objects out to a fixed-size byte-buffer. Instead of copying data-bytes out \"by hand\" using pointer-arithmetic and memcpy() / htonl() / muscleCopyOut() /etc, you can declare a DataFlattener on the stack and call WriteInt32() / WriteFloat() / WriteFlat() /etc on it. DataFlattener 's methods automatically handle endian-conversion and unaligned-data-write-safety issues. DataFlattener contains logic to detect when the calling code didn't write the expected number of bytes, and notify the programmer via an assertion failure when that happens. DataFlattener is a synonym for LittleEndianDataFlattener (since MUSCLE uses little-endian data by default). BigEndianDataFlattener and NativeEndianDataFlattener classes are also available. Checked*DataFlattener classes that do per-method-call bounds-checking are also available, and they can automatically resize a ByteBuffer larger as data is written. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/bytebuffer (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: bytebuffer/example_3_endian.cpp message/example_4_add_flat.cpp flattenable/example_1_basic_usage.cpp","title":"DataFlattener"},{"location":"dataflattener/#muscledataflattener-class-api","text":"#include \"util/DataFlattener.h\" A DataFlattener is a lightweight binary-data-writer object that makes it easy and safe to write/serialize POD data and Flattenable / PseudoFlattenable objects out to a fixed-size byte-buffer. Instead of copying data-bytes out \"by hand\" using pointer-arithmetic and memcpy() / htonl() / muscleCopyOut() /etc, you can declare a DataFlattener on the stack and call WriteInt32() / WriteFloat() / WriteFlat() /etc on it. DataFlattener 's methods automatically handle endian-conversion and unaligned-data-write-safety issues. DataFlattener contains logic to detect when the calling code didn't write the expected number of bytes, and notify the programmer via an assertion failure when that happens. DataFlattener is a synonym for LittleEndianDataFlattener (since MUSCLE uses little-endian data by default). BigEndianDataFlattener and NativeEndianDataFlattener classes are also available. Checked*DataFlattener classes that do per-method-call bounds-checking are also available, and they can automatically resize a ByteBuffer larger as data is written. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/bytebuffer (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: bytebuffer/example_3_endian.cpp message/example_4_add_flat.cpp flattenable/example_1_basic_usage.cpp","title":"muscle::DataFlattener class (API)"},{"location":"dataio/","text":"muscle::DataIO class (API) #include \"dataio/DataIO.h\" DataIO is an interface to any object that can read or write raw I/O data. Similar to: QIODevice , BDataIO Used to unify networking, file, child-process, RS-232, and various other I/O APIs behind a single generic interface A program written to use a DataIO can be easily modified to talk to any kind of I/O hardware (see muscle/test/hexterm.cpp for a good example) Both blocking and non-blocking I/O are supported. virtual int32 Read(void * buf, uint32 bufSize) is implemented by DataIO subclasses to read data from the hardware into a buffer virtual int32 Write(const void * buf, uint32 bufSize) is implemented by DataIO subclasses to write data from a buffer to the hardware GetReadSelectSocket() returns a reference to a socket that select() (or SocketMultiplexer ) can use to tell when the I/O is ready-for-read. GetWriteSelectSocket() returns a reference to a socket that select() (or SocketMultiplexer ) can use to tell when the I/O is ready-for-write. (Often this is the same socket returned by GetReadSelectSocket() , but not always!) Basic I/O devices (that support only Read() and Write() operations) should subclass DataIO directly. File-like devices with seek() capability should subclass SeekableDataIO instead. Devices with UDP-style per-packet-addressing abilities should subclass PacketDataIO instead. Classes that want to act as a \"facade\" in front of any existing DataIO object (to unintrusively modify its behavior) should subclass ProxyDataIO instead. DataIO class methods can be called directly (as shown in the dataio examples folder), but their primary use-case is to be installed (via DataIORef ) into an AbstractMessageIOGateway object as part of the High-Level Messaging API. Some direct subclasses of DataIO are: TCPSocketDataIO , StdinDataIO , RS232DataIO , ChildProcessDataIO , NullDataIO . Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/dataio (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: dataio/example_1_basic_usage.cpp dataio/example_2_tcp_server.cpp dataio/example_3_seekable_dataio.cpp dataio/example_4_idioms.cpp dataio/example_5_packet_dataio.cpp dataio/example_6_child_process.cpp","title":"DataIO"},{"location":"dataio/#muscledataio-class-api","text":"#include \"dataio/DataIO.h\" DataIO is an interface to any object that can read or write raw I/O data. Similar to: QIODevice , BDataIO Used to unify networking, file, child-process, RS-232, and various other I/O APIs behind a single generic interface A program written to use a DataIO can be easily modified to talk to any kind of I/O hardware (see muscle/test/hexterm.cpp for a good example) Both blocking and non-blocking I/O are supported. virtual int32 Read(void * buf, uint32 bufSize) is implemented by DataIO subclasses to read data from the hardware into a buffer virtual int32 Write(const void * buf, uint32 bufSize) is implemented by DataIO subclasses to write data from a buffer to the hardware GetReadSelectSocket() returns a reference to a socket that select() (or SocketMultiplexer ) can use to tell when the I/O is ready-for-read. GetWriteSelectSocket() returns a reference to a socket that select() (or SocketMultiplexer ) can use to tell when the I/O is ready-for-write. (Often this is the same socket returned by GetReadSelectSocket() , but not always!) Basic I/O devices (that support only Read() and Write() operations) should subclass DataIO directly. File-like devices with seek() capability should subclass SeekableDataIO instead. Devices with UDP-style per-packet-addressing abilities should subclass PacketDataIO instead. Classes that want to act as a \"facade\" in front of any existing DataIO object (to unintrusively modify its behavior) should subclass ProxyDataIO instead. DataIO class methods can be called directly (as shown in the dataio examples folder), but their primary use-case is to be installed (via DataIORef ) into an AbstractMessageIOGateway object as part of the High-Level Messaging API. Some direct subclasses of DataIO are: TCPSocketDataIO , StdinDataIO , RS232DataIO , ChildProcessDataIO , NullDataIO . Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/dataio (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: dataio/example_1_basic_usage.cpp dataio/example_2_tcp_server.cpp dataio/example_3_seekable_dataio.cpp dataio/example_4_idioms.cpp dataio/example_5_packet_dataio.cpp dataio/example_6_child_process.cpp","title":"muscle::DataIO class (API)"},{"location":"datanode/","text":"muscle::DataNode class (API) #include \"reflector/DataNode.h\" DataNode is used by the StorageReflectSession class to represent one node in the MUSCLE server-side node-tree-database. Each DataNode contains one Message (held via a MessageRef ) and (optionally) a Hashtable<const String *, DataNodeRef> holding one or more child DataNodes . DataNode objects keep track of which StorageReflectSession s are currently subscribed to them, and call a notification method on those StorageReflectSession objects whenever the state of the DataNode changes. A DataNode object can optionally keep a child-node-index that tracks the ordering of its children and informs subscribed clients when that ordering changes. This functionality requires some extra overhead, so it is not enabled by default. (It gets activated the first time a DataNode has its InsertOrderedChild() method called) Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/reflector (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file)","title":"DataNode"},{"location":"datanode/#muscledatanode-class-api","text":"#include \"reflector/DataNode.h\" DataNode is used by the StorageReflectSession class to represent one node in the MUSCLE server-side node-tree-database. Each DataNode contains one Message (held via a MessageRef ) and (optionally) a Hashtable<const String *, DataNodeRef> holding one or more child DataNodes . DataNode objects keep track of which StorageReflectSession s are currently subscribed to them, and call a notification method on those StorageReflectSession objects whenever the state of the DataNode changes. A DataNode object can optionally keep a child-node-index that tracks the ordering of its children and informs subscribed clients when that ordering changes. This functionality requires some extra overhead, so it is not enabled by default. (It gets activated the first time a DataNode has its InsertOrderedChild() method called) Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/reflector (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file)","title":"muscle::DataNode class (API)"},{"location":"dataunflattener/","text":"muscle::DataUnflattener class (API) #include \"util/DataUnflattener.h\" A DataUnflattener is a lightweight binary-data-reader object that makes it easy and safe to read in serialized POD data and Flattenable / PseudoFlattenable object-bytes from a byte-buffer. Instead of copying data-bytes in \"by hand\" using pointer-arithmetic and memcpy() / ntohl() / muscleCopyIn() /etc, you can declare a DataUnflattener on the stack and call ReadInt32() / ReadFloat() / ReadFlat() /etc on it. DataUnflattener 's methods deal with endian-conversion and unaligned-data-read-safety issues. DataUnflattener is a synonym for LittleEndianDataUnflattener (since MUSCLE uses little-endian data by default). Reads from a raw/fixed-size array of uint8 or from a ByteBuffer object. DataUnflattener keeps an internal parse-error flag that gets set whenever an error occurs, so instead of checking for errors separately after every Read*() call, you can (if you prefer) just attempt to read everything, and then call return GetStatus() at the end of your Unflatten() method to return whether everything worked or not. BigEndianDataUnflattener and NativeEndianDataUnflattener classes are also available. Unchecked*DataUnflattener classes are available as a more-efficient implementation that can be used by code that has already done its own bounds-checking. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/bytebuffer (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: bytebuffer/example_3_endian.cpp message/example_4_add_flat.cpp flattenable/example_1_basic_usage.cpp","title":"DataUnflattener"},{"location":"dataunflattener/#muscledataunflattener-class-api","text":"#include \"util/DataUnflattener.h\" A DataUnflattener is a lightweight binary-data-reader object that makes it easy and safe to read in serialized POD data and Flattenable / PseudoFlattenable object-bytes from a byte-buffer. Instead of copying data-bytes in \"by hand\" using pointer-arithmetic and memcpy() / ntohl() / muscleCopyIn() /etc, you can declare a DataUnflattener on the stack and call ReadInt32() / ReadFloat() / ReadFlat() /etc on it. DataUnflattener 's methods deal with endian-conversion and unaligned-data-read-safety issues. DataUnflattener is a synonym for LittleEndianDataUnflattener (since MUSCLE uses little-endian data by default). Reads from a raw/fixed-size array of uint8 or from a ByteBuffer object. DataUnflattener keeps an internal parse-error flag that gets set whenever an error occurs, so instead of checking for errors separately after every Read*() call, you can (if you prefer) just attempt to read everything, and then call return GetStatus() at the end of your Unflatten() method to return whether everything worked or not. BigEndianDataUnflattener and NativeEndianDataUnflattener classes are also available. Unchecked*DataUnflattener classes are available as a more-efficient implementation that can be used by code that has already done its own bounds-checking. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/bytebuffer (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: bytebuffer/example_3_endian.cpp message/example_4_add_flat.cpp flattenable/example_1_basic_usage.cpp","title":"muscle::DataUnflattener class (API)"},{"location":"detectnetworkconfigchangessession/","text":"muscle::DetectNetworkConfigChangesSession class (API) #include \"system/DetectNetworkConfigChangesSession.h\" An OS-neutral mechanism for detecting (and reacting to) changes to the host computer's networking configuration. This session can be added to your ReflectServer if you want to react to changes in the computer's network config (e.g. Ethernet interfaces going up or down, user changing DHCP settings, IP addresses changing, etc) As a bonus, this session can also tell you when the computer is about to go to sleep , or just woke up Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/detectnetworkconfigchangessession (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: detectnetworkconfigchangessession/example_1_basic_usage.cpp detectnetworkconfigchangessession/example_2_without_subclassing.cpp","title":"DetectNetworkConfigChangesSession"},{"location":"detectnetworkconfigchangessession/#muscledetectnetworkconfigchangessession-class-api","text":"#include \"system/DetectNetworkConfigChangesSession.h\" An OS-neutral mechanism for detecting (and reacting to) changes to the host computer's networking configuration. This session can be added to your ReflectServer if you want to react to changes in the computer's network config (e.g. Ethernet interfaces going up or down, user changing DHCP settings, IP addresses changing, etc) As a bonus, this session can also tell you when the computer is about to go to sleep , or just woke up Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/detectnetworkconfigchangessession (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: detectnetworkconfigchangessession/example_1_basic_usage.cpp detectnetworkconfigchangessession/example_2_without_subclassing.cpp","title":"muscle::DetectNetworkConfigChangesSession class (API)"},{"location":"directory/","text":"muscle::Directory class (API) #include \"util/Directory.h\" Directory is an OS-neutral API for iterating over the contents of a filesystem directory. Similar to: QDir Can also create and delete sub-directories (recursively if necessary) Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/directory (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: directory/example_1_basic_usage.cpp","title":"Directory"},{"location":"directory/#muscledirectory-class-api","text":"#include \"util/Directory.h\" Directory is an OS-neutral API for iterating over the contents of a filesystem directory. Similar to: QDir Can also create and delete sub-directories (recursively if necessary) Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/directory (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: directory/example_1_basic_usage.cpp","title":"muscle::Directory class (API)"},{"location":"dumbreflectsession/","text":"muscle::DumbReflectSession class (API) #include \"reflector/DumbReflectSession.h\" DumbReflectSession is a very simple concrete implemention of the AbstractReflectSession session interface. DumbReflectSession::MessageReceivedFromGateway() is implemented to forward the client's Message on to all the other session objects on the ReflectServer . DumbReflectSession::MessageReceivedFromSession() is implemented to forward the fellow-session's Message out to the session's own gateway (and thus on to the session's own client) In this way, a ReflectServer with a DumbReflectSessionFactory object installed becomes a simple one-to-many \"chat room\" style reflector, with any Message object sent by any client getting \"reflected\" to all the other connected clients (but not back to the sending client). This class is good for a simple chat server or a simple demonstration, but it isn't much used otherwise (except as the base class for the StorageReflectSession class, where more sophisticated wildcard-based routing logic is implemented) Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/reflector (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: reflector/example_1_dumb_server.cpp reflector/example_2_dumb_client.cpp reflector/example_3_annotated_dumb_server.cpp","title":"DumbReflectSession"},{"location":"dumbreflectsession/#muscledumbreflectsession-class-api","text":"#include \"reflector/DumbReflectSession.h\" DumbReflectSession is a very simple concrete implemention of the AbstractReflectSession session interface. DumbReflectSession::MessageReceivedFromGateway() is implemented to forward the client's Message on to all the other session objects on the ReflectServer . DumbReflectSession::MessageReceivedFromSession() is implemented to forward the fellow-session's Message out to the session's own gateway (and thus on to the session's own client) In this way, a ReflectServer with a DumbReflectSessionFactory object installed becomes a simple one-to-many \"chat room\" style reflector, with any Message object sent by any client getting \"reflected\" to all the other connected clients (but not back to the sending client). This class is good for a simple chat server or a simple demonstration, but it isn't much used otherwise (except as the base class for the StorageReflectSession class, where more sophisticated wildcard-based routing logic is implemented) Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/reflector (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: reflector/example_1_dumb_server.cpp reflector/example_2_dumb_client.cpp reflector/example_3_annotated_dumb_server.cpp","title":"muscle::DumbReflectSession class (API)"},{"location":"filedataio/","text":"muscle::FileDataIO class (API) #include \"dataio/FileDataIO.h\" FileDataIO is used to read/write data from a standard C file-handle ( FILE * , as returned by fopen() ). The FileDataIO object will assume ownership of the FILE * handle you pass in to it, so don't need to (and shouldn't) call fclose() on it yourself. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/dataio (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: dataio/example_3_seekable_dataio.cpp dataio/example_4_idioms.cpp","title":"FileDataIO"},{"location":"filedataio/#musclefiledataio-class-api","text":"#include \"dataio/FileDataIO.h\" FileDataIO is used to read/write data from a standard C file-handle ( FILE * , as returned by fopen() ). The FileDataIO object will assume ownership of the FILE * handle you pass in to it, so don't need to (and shouldn't) call fclose() on it yourself. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/dataio (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: dataio/example_3_seekable_dataio.cpp dataio/example_4_idioms.cpp","title":"muscle::FileDataIO class (API)"},{"location":"filedescriptordataio/","text":"muscle::FileDescriptorDataIO class (API) #include \"dataio/FileDescriptorDataIO.h\" FileDescriptorDataIO is used to read/write data from a Unix low-level file-descriptor-handle ( int , as returned by open() , etc). The FileDescriptorDataIO object will assume ownership of the int handle you pass in to it, so don't need to (and shouldn't) call close() on it yourself. FileDescriptorDataIO class can't be used under Windows, since Windows doesn't have this sort of low-level file-handles. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/dataio (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file)","title":"FileDescriptorDataIO"},{"location":"filedescriptordataio/#musclefiledescriptordataio-class-api","text":"#include \"dataio/FileDescriptorDataIO.h\" FileDescriptorDataIO is used to read/write data from a Unix low-level file-descriptor-handle ( int , as returned by open() , etc). The FileDescriptorDataIO object will assume ownership of the int handle you pass in to it, so don't need to (and shouldn't) call close() on it yourself. FileDescriptorDataIO class can't be used under Windows, since Windows doesn't have this sort of low-level file-handles. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/dataio (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file)","title":"muscle::FileDescriptorDataIO class (API)"},{"location":"filepathinfo/","text":"muscle::FilePathInfo class (API) #include \"util/FilePathInfo.h\" FilePathInfo gathers and reports information about a given file/directory path. Similar to: QFileInfo , struct stat Info includes whether or not any entry exists at the given path, whether it's a file, directory, or symlink, the file's size, its creation-timestamp, etc. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/filepathinfo (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: filepathinfo/example_1_basic_usage.cpp","title":"FilePathInfo"},{"location":"filepathinfo/#musclefilepathinfo-class-api","text":"#include \"util/FilePathInfo.h\" FilePathInfo gathers and reports information about a given file/directory path. Similar to: QFileInfo , struct stat Info includes whether or not any entry exists at the given path, whether it's a file, directory, or symlink, the file's size, its creation-timestamp, etc. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/filepathinfo (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: filepathinfo/example_1_basic_usage.cpp","title":"muscle::FilePathInfo class (API)"},{"location":"flatcountable/","text":"muscle::FlatCountable class (API) #include \"support/FlatCountable.h\" Abstract interface representing an object that is both Flattenable and RefCountable . Inherits both of the above-mentioned superclasses. FlatCountable objects are doubly useful, since they may be added to Message objects by-reference (thus avoiding any unnecesary data copying during inter-thread communication) but can also be automatically flattened if necessary, i.e. if the Message gets flattened to be sent outside the process's boundaries (e.g. to a file or to the network)","title":"FlatCountable"},{"location":"flatcountable/#muscleflatcountable-class-api","text":"#include \"support/FlatCountable.h\" Abstract interface representing an object that is both Flattenable and RefCountable . Inherits both of the above-mentioned superclasses. FlatCountable objects are doubly useful, since they may be added to Message objects by-reference (thus avoiding any unnecesary data copying during inter-thread communication) but can also be automatically flattened if necessary, i.e. if the Message gets flattened to be sent outside the process's boundaries (e.g. to a file or to the network)","title":"muscle::FlatCountable class (API)"},{"location":"flattenable/","text":"muscle::Flattenable class (API) #include \"support/Flattenable.h\" Abstract interface representing an object that knows how to Flatten() itself (by writing its current state into a raw-byte-array, via some well-defined encoding), and Unflatten() itself (by reading in a new state for itself from a previously-flattened-to raw-byte-array) Used for low-level object-persistence and networking, and also for adding user-defined data types to a Message object. Similar to: BFlattenable Flattenable::TypeCode() returns a 32-bit type-code used to identify the object's type (useful for quick sanity-checking) Flattenable::FlattenedSize() must return how many bytes Flatten() would write out if called. PseudoFlattenable is a templated interface class, used in the same way as Flattenable , but it declares no virtual methods. Lightweight classes that don't require runtime-polymorphic behavior can inherit from PseudoFlattenable and be used much like Flattenable objects, via templated methods (like Message::AddFlat() and Message::FindFlat() ) without having to pay the extra-pointer-per-object tax that comes with using virtual methods. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/flattenable (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: flattenable/example_1_basic_usage.cpp message/example_4_add_flat.cpp","title":"Flattenable/PseudoFlattenable"},{"location":"flattenable/#muscleflattenable-class-api","text":"#include \"support/Flattenable.h\" Abstract interface representing an object that knows how to Flatten() itself (by writing its current state into a raw-byte-array, via some well-defined encoding), and Unflatten() itself (by reading in a new state for itself from a previously-flattened-to raw-byte-array) Used for low-level object-persistence and networking, and also for adding user-defined data types to a Message object. Similar to: BFlattenable Flattenable::TypeCode() returns a 32-bit type-code used to identify the object's type (useful for quick sanity-checking) Flattenable::FlattenedSize() must return how many bytes Flatten() would write out if called. PseudoFlattenable is a templated interface class, used in the same way as Flattenable , but it declares no virtual methods. Lightweight classes that don't require runtime-polymorphic behavior can inherit from PseudoFlattenable and be used much like Flattenable objects, via templated methods (like Message::AddFlat() and Message::FindFlat() ) without having to pay the extra-pointer-per-object tax that comes with using virtual methods. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/flattenable (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: flattenable/example_1_basic_usage.cpp message/example_4_add_flat.cpp","title":"muscle::Flattenable class (API)"},{"location":"hashtable/","text":"muscle::Hashtable class (API) #include \"util/Hashtable.h\" Templated container class Hashtable<Key,Value> is a hash-based dictionary class that also maintains a consistent, user-specifiable iteration order. Similar to: std::map<K,V> , and std::unordered_map<K,V> (combined!), java.util.Hashtable , QHash , etc. O(1) Get() / ContainsKey() / Put() / Remove() O(1) RemoveFirst() / RemoveLast() O(N*log(N)) SortByKey() O(N*log(N)) SortByValue() O(1) MoveToFront() / MoveToBack() / MoveToBefore() / MoveToBehind() O(1) SwapContents() Iteration of key/value pairs is done via HashtableIterator class Addresses of key and value objects never change (except when the Hashtable 's internal array is reallocated) No heap allocations/deletions during use (except when the Hashtable 's internal array is reallocated) If you know how many key/value pairs you need to store, you can (optionally) call EnsureSize() up-front to avoid unnecessary array-reallocations while adding data. It's okay to modify or delete the Hashtable during an iteration -- any active HashtableIterator (s) will handle the modification gracefully. Unlike many other hash table implementations, all Hashtable operations remain fully efficient even when the table is at 100% load-factor -- so there's no need to reallocate the underlying array until it has become completely full. This class is typically used when efficient key->value lookups are desired, or when the software wants to maintain a set of data that automatically enforces the uniqueness of keys in a key->value set. Since it maintains the iteration-ordering of its contents, it can also be used as a keyed FIFO or LRU-cache. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/hashtable (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: hashtable/example_1_basic_usage.cpp hashtable/example_2_sorting.cpp hashtable/example_3_iterating.cpp hashtable/example_4_idioms.cpp hashtable/example_5_ordered_tables.cpp hashtable/example_6_key_types.cpp","title":"Hashtable"},{"location":"hashtable/#musclehashtable-class-api","text":"#include \"util/Hashtable.h\" Templated container class Hashtable<Key,Value> is a hash-based dictionary class that also maintains a consistent, user-specifiable iteration order. Similar to: std::map<K,V> , and std::unordered_map<K,V> (combined!), java.util.Hashtable , QHash , etc. O(1) Get() / ContainsKey() / Put() / Remove() O(1) RemoveFirst() / RemoveLast() O(N*log(N)) SortByKey() O(N*log(N)) SortByValue() O(1) MoveToFront() / MoveToBack() / MoveToBefore() / MoveToBehind() O(1) SwapContents() Iteration of key/value pairs is done via HashtableIterator class Addresses of key and value objects never change (except when the Hashtable 's internal array is reallocated) No heap allocations/deletions during use (except when the Hashtable 's internal array is reallocated) If you know how many key/value pairs you need to store, you can (optionally) call EnsureSize() up-front to avoid unnecessary array-reallocations while adding data. It's okay to modify or delete the Hashtable during an iteration -- any active HashtableIterator (s) will handle the modification gracefully. Unlike many other hash table implementations, all Hashtable operations remain fully efficient even when the table is at 100% load-factor -- so there's no need to reallocate the underlying array until it has become completely full. This class is typically used when efficient key->value lookups are desired, or when the software wants to maintain a set of data that automatically enforces the uniqueness of keys in a key->value set. Since it maintains the iteration-ordering of its contents, it can also be used as a keyed FIFO or LRU-cache. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/hashtable (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: hashtable/example_1_basic_usage.cpp hashtable/example_2_sorting.cpp hashtable/example_3_iterating.cpp hashtable/example_4_idioms.cpp hashtable/example_5_ordered_tables.cpp hashtable/example_6_key_types.cpp","title":"muscle::Hashtable class (API)"},{"location":"ipaddress/","text":"muscle::IPAddress class (API) #include \"util/IPAddress.h\" Holds a numeric IPv4 or IPv6 address. Similar to: QHostAddress Inherits PseudoFlattenable for easy archiving/transmission IPAddress also includes a scope-index (used for link-local IPv6 addresses only) IPAddressAndPort contains an IPAddress object plus a port-number IPAddress and IPAddressAndPort include ToString() and SetFromString() methods for easy conversion to (and from) user-readable Strings . Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/ipaddress (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: ipaddress/example_1_basic_usage.cpp ipaddress/example_2_interactive_ipaddress.cpp ipaddress/example_3_interactive_ipaddress_and_port.cpp","title":"IPAddress/IPAddressAndPort"},{"location":"ipaddress/#muscleipaddress-class-api","text":"#include \"util/IPAddress.h\" Holds a numeric IPv4 or IPv6 address. Similar to: QHostAddress Inherits PseudoFlattenable for easy archiving/transmission IPAddress also includes a scope-index (used for link-local IPv6 addresses only) IPAddressAndPort contains an IPAddress object plus a port-number IPAddress and IPAddressAndPort include ToString() and SetFromString() methods for easy conversion to (and from) user-readable Strings . Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/ipaddress (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: ipaddress/example_1_basic_usage.cpp ipaddress/example_2_interactive_ipaddress.cpp ipaddress/example_3_interactive_ipaddress_and_port.cpp","title":"muscle::IPAddress class (API)"},{"location":"logtime/","text":"Logging API (API) #include \"syslog/SysLog.h\" MUSCLE's logging mechanism, for debugging, troubleshooting, and status/monitoring purposes. Log() outputs just the specified text, e.g. Hello. LogTime() outputs the specified text with a prefix, e.g. [I 03/20 11:45:56] Hello. Each line of log-output is tagged with one of the following severity levels MUSCLE_LOG_TRACE - for fine-grained tracing of program execution MUSCLE_LOG_DEBUG - for use during debugging only MUSCLE_LOG_INFO - normal severity level, for informational messages MUSCLE_LOG_WARNING - warning about a potential problem MUSCLE_LOG_ERROR - report of an error (but program execution can continue) MUSCLE_LOG_CRITICALERROR - report of a critical error (program execution may be in trouble) Strings passed to Log() and LogTime() should include newline chars where appropriate to indicate the end of a log-line (e.g. LogTime(MUSCLE_LOG_INFO, \"Hi!\\n\"); ) printf() -style variable interpolation is supported (e.g. LogTime(MUSCLE_LOG_INFO, \"3+2=%i\\n\", 5); ) Log-text can be sent to stdout and/or to a log file. Supports automatic creation, rotation, and deletion of log files, if desired. You can also register a LogCallback or LogLineCallback object to execute a user-supplied callback routine whenever text is logged. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/logtime (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: logtime/example_1_basic_usage.cpp logtime/example_2_log_files.cpp logtime/example_3_advanced_log_files.cpp logtime/example_4_log_callbacks.cpp","title":"LogTime/LogCallback"},{"location":"logtime/#logging-api-api","text":"#include \"syslog/SysLog.h\" MUSCLE's logging mechanism, for debugging, troubleshooting, and status/monitoring purposes. Log() outputs just the specified text, e.g. Hello. LogTime() outputs the specified text with a prefix, e.g. [I 03/20 11:45:56] Hello. Each line of log-output is tagged with one of the following severity levels MUSCLE_LOG_TRACE - for fine-grained tracing of program execution MUSCLE_LOG_DEBUG - for use during debugging only MUSCLE_LOG_INFO - normal severity level, for informational messages MUSCLE_LOG_WARNING - warning about a potential problem MUSCLE_LOG_ERROR - report of an error (but program execution can continue) MUSCLE_LOG_CRITICALERROR - report of a critical error (program execution may be in trouble) Strings passed to Log() and LogTime() should include newline chars where appropriate to indicate the end of a log-line (e.g. LogTime(MUSCLE_LOG_INFO, \"Hi!\\n\"); ) printf() -style variable interpolation is supported (e.g. LogTime(MUSCLE_LOG_INFO, \"3+2=%i\\n\", 5); ) Log-text can be sent to stdout and/or to a log file. Supports automatic creation, rotation, and deletion of log files, if desired. You can also register a LogCallback or LogLineCallback object to execute a user-supplied callback routine whenever text is logged. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/logtime (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: logtime/example_1_basic_usage.cpp logtime/example_2_log_files.cpp logtime/example_3_advanced_log_files.cpp logtime/example_4_log_callbacks.cpp","title":"Logging API (API)"},{"location":"low-level-sockets-api/","text":"Low-Level Sockets (API) #include \"util/NetworkUtilityFunctions.h\" MUSCLE's Low-Level Sockets API is very similar to the Berkeley BSD Sockets API, except it uses ConstSocketRef objects instead of int objects for file descriptors, so there is almost no possibility of 'leaking' file descriptors. Also it is much easier to use correctly than the BSD sockets API (at the cost of being applicable to IPv4 and IPv6 only -- if you need to use some other obscure type of networking layer like DECnet, then most of the functions in NetworkUtilityFunctions.h won't help you much)","title":"Overview"},{"location":"low-level-sockets-api/#low-level-sockets-api","text":"#include \"util/NetworkUtilityFunctions.h\" MUSCLE's Low-Level Sockets API is very similar to the Berkeley BSD Sockets API, except it uses ConstSocketRef objects instead of int objects for file descriptors, so there is almost no possibility of 'leaking' file descriptors. Also it is much easier to use correctly than the BSD sockets API (at the cost of being applicable to IPv4 and IPv6 only -- if you need to use some other obscure type of networking layer like DECnet, then most of the functions in NetworkUtilityFunctions.h won't help you much)","title":"Low-Level Sockets (API)"},{"location":"message/","text":"muscle::Message class (API) #include \"message/Message.h\" Message is the main unit of network and inter-thread communication in MUSCLE. Similar to: BMessage , JSON Message (?) , XML (?) Can hold any number of uniquely-named data-fields (up to 2^32) Each data field has a UTF-8 name, a fixed type, and 1 or more data-values of that type. Supported field-data-types include: int8 , int16 , int32 , int64 , float , double , String , Message , Point , Rect , plus any arbitrary additional types the user cares to define. Each Message also includes a single uint32 \"what-code\", which is typically used for tagging and quick dispatch (e.g. via a switch statement) A Message is Flattenable : i.e. serializable to a platform-neutral flattened-bytes representation that can be saved to disk or transmitted across the network, and later parsed unambiguously under any OS, CPU, or language. A Message is RefCountable , which allows efficient (zero-copy) in-process transmission of Messages to other threads and functions, and efficient adding of Message objects to data structures (like the server-side DataNode tree) Call AddInt32() / AddString() / AddFloat() / AddMessage() /etc to add field-data to a Message . Call FindInt32() / FindString() / FindFloat() / FindMessage() /etc to retrieve field-data from a Message . Call GetInt32() / GetString() / GetFloat() / GetMessage() /etc to either retrieve field-data from a Message , or retrieve a default value if the requested data doesn't exist. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/message (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: message/example_1_basic_usage.cpp message/example_2_nested_messages.cpp message/example_3_add_archive.cpp message/example_4_add_flat.cpp message/example_5_field_iteration.cpp","title":"Message"},{"location":"message/#musclemessage-class-api","text":"#include \"message/Message.h\" Message is the main unit of network and inter-thread communication in MUSCLE. Similar to: BMessage , JSON Message (?) , XML (?) Can hold any number of uniquely-named data-fields (up to 2^32) Each data field has a UTF-8 name, a fixed type, and 1 or more data-values of that type. Supported field-data-types include: int8 , int16 , int32 , int64 , float , double , String , Message , Point , Rect , plus any arbitrary additional types the user cares to define. Each Message also includes a single uint32 \"what-code\", which is typically used for tagging and quick dispatch (e.g. via a switch statement) A Message is Flattenable : i.e. serializable to a platform-neutral flattened-bytes representation that can be saved to disk or transmitted across the network, and later parsed unambiguously under any OS, CPU, or language. A Message is RefCountable , which allows efficient (zero-copy) in-process transmission of Messages to other threads and functions, and efficient adding of Message objects to data structures (like the server-side DataNode tree) Call AddInt32() / AddString() / AddFloat() / AddMessage() /etc to add field-data to a Message . Call FindInt32() / FindString() / FindFloat() / FindMessage() /etc to retrieve field-data from a Message . Call GetInt32() / GetString() / GetFloat() / GetMessage() /etc to either retrieve field-data from a Message , or retrieve a default value if the requested data doesn't exist. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/message (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: message/example_1_basic_usage.cpp message/example_2_nested_messages.cpp message/example_3_add_archive.cpp message/example_4_add_flat.cpp message/example_5_field_iteration.cpp","title":"muscle::Message class (API)"},{"location":"messageiogateway/","text":"muscle::MessageIOGateway class (API) #include \"iogateway/MessageIOGateway.h\" The MessageIOGateway class converts any Message object into a byte-stream (and vice-versa) using MUSCLE's own binary protocol. The default implementation of the CreateGateway() method of the session classes creates a MessageIOGateway object. The binary protocol is based on the output of the Message::Flatten() method, with a couple of additional per-Message header-fields for framing. MessageIOGateway is primarily used in conjunction with TCP connections, but will work over UDP as well (if the flattened-data representation of the Message objects will fit inside a UDP packet -- for a more comprehensive Messages-over-UDP implementation, see the PacketTunnelIOGateway class) MessageIOGateway can optionally ZLib-compress its outgoing data stream, to reduce network bandwidth (at the cost of higher CPU usage). (This compression will be transparent to user of the receiving MessageIOGateway ) (See MessageIOGateway::SetOutgoingEncoding() ) Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/iogateway (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: iogateway/example_1_message_to_file.cpp iogateway/example_2_message_to_tcp.cpp","title":"MessageIOGateway"},{"location":"messageiogateway/#musclemessageiogateway-class-api","text":"#include \"iogateway/MessageIOGateway.h\" The MessageIOGateway class converts any Message object into a byte-stream (and vice-versa) using MUSCLE's own binary protocol. The default implementation of the CreateGateway() method of the session classes creates a MessageIOGateway object. The binary protocol is based on the output of the Message::Flatten() method, with a couple of additional per-Message header-fields for framing. MessageIOGateway is primarily used in conjunction with TCP connections, but will work over UDP as well (if the flattened-data representation of the Message objects will fit inside a UDP packet -- for a more comprehensive Messages-over-UDP implementation, see the PacketTunnelIOGateway class) MessageIOGateway can optionally ZLib-compress its outgoing data stream, to reduce network bandwidth (at the cost of higher CPU usage). (This compression will be transparent to user of the receiving MessageIOGateway ) (See MessageIOGateway::SetOutgoingEncoding() ) Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/iogateway (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: iogateway/example_1_message_to_file.cpp iogateway/example_2_message_to_tcp.cpp","title":"muscle::MessageIOGateway class (API)"},{"location":"messagetransceiverthread/","text":"muscle::MessageTransceiverThread class (API) #include \"system/MessageTransceiverThread.h\" MessageTransceiverThread object holds a captive internal thread, like the Thread class, except this thread's event loop is a full ReflectServer event loop. Many ReflectServer -style methods (e.g. AddNewConnectSession() , PutAcceptFactory() , etc are implemented in MessageTransceiverThread as asynchronous calls to their like-named methods in the internal thread's ReflectServer . The purpose of MessageTransceiverThread is to allow your program to do its networking I/O in a separate thread, where it won't interfere with whatever your main thread is doing. Feedback from the internal thread is retrieved by calling the GetNextEventFromInternalThread() method. For Qt-based programs, see the QMessageTransceiverThread class, which subclasses this one and adds a Qt signals-and-slots API to make the events integration easier to use. Other MessageTransceiverThread subclasses are available for other runtime environments (e.g. SDLMessageTransceiverThread for SDL-base programs, Win32MessageTransceiverThread for WinAPI-based programs, etc) Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/messagetransceiverthread (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: messagetransceiverthread/example_1_threaded_smart_client.cpp","title":"MessageTransceiverThread"},{"location":"messagetransceiverthread/#musclemessagetransceiverthread-class-api","text":"#include \"system/MessageTransceiverThread.h\" MessageTransceiverThread object holds a captive internal thread, like the Thread class, except this thread's event loop is a full ReflectServer event loop. Many ReflectServer -style methods (e.g. AddNewConnectSession() , PutAcceptFactory() , etc are implemented in MessageTransceiverThread as asynchronous calls to their like-named methods in the internal thread's ReflectServer . The purpose of MessageTransceiverThread is to allow your program to do its networking I/O in a separate thread, where it won't interfere with whatever your main thread is doing. Feedback from the internal thread is retrieved by calling the GetNextEventFromInternalThread() method. For Qt-based programs, see the QMessageTransceiverThread class, which subclasses this one and adds a Qt signals-and-slots API to make the events integration easier to use. Other MessageTransceiverThread subclasses are available for other runtime environments (e.g. SDLMessageTransceiverThread for SDL-base programs, Win32MessageTransceiverThread for WinAPI-based programs, etc) Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/messagetransceiverthread (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: messagetransceiverthread/example_1_threaded_smart_client.cpp","title":"muscle::MessageTransceiverThread class (API)"},{"location":"micromessage-api/","text":"MicroMessage bare-bones C API #include \"lang/c/micromessage/MicroMessage.h\" #include \"lang/c/micromessage/MicroMessageGateway.h The MicroMessage API is an extremely bare-bones, low-level C implementation of the MUSCLE Message and MessageIOGateway APIs. This implementation never bothers to flatten or unflatten message objects at all; instead it reads and writes flattened-message-data directly from/to a raw buffer of bytes. That makes this implementation very efficient (it never copies any Message data, and it never performs any heap-allocations), but it does restrict its functionality somewhat (compared to the C++ implementation). In particular, when constructing a MicroMessage data-buffer, fields can only be appended. Fields already present in the MicroMessage buffer are considered read-only. Also, you can only add as much data as will fit into the byte-buffer you provided. Attempts to add more data than that will fail. The only two files needed to use the MicroMessage API are MicroMessage.c and (optionally) MicroMessageGateway.c These files do not depend on any other files outside of this folder, except for support/MuscleSupport.h . See also the micromessage README.TXT file","title":"Overview"},{"location":"micromessage-api/#micromessage-bare-bones-c-api","text":"#include \"lang/c/micromessage/MicroMessage.h\" #include \"lang/c/micromessage/MicroMessageGateway.h The MicroMessage API is an extremely bare-bones, low-level C implementation of the MUSCLE Message and MessageIOGateway APIs. This implementation never bothers to flatten or unflatten message objects at all; instead it reads and writes flattened-message-data directly from/to a raw buffer of bytes. That makes this implementation very efficient (it never copies any Message data, and it never performs any heap-allocations), but it does restrict its functionality somewhat (compared to the C++ implementation). In particular, when constructing a MicroMessage data-buffer, fields can only be appended. Fields already present in the MicroMessage buffer are considered read-only. Also, you can only add as much data as will fit into the byte-buffer you provided. Attempts to add more data than that will fail. The only two files needed to use the MicroMessage API are MicroMessage.c and (optionally) MicroMessageGateway.c These files do not depend on any other files outside of this folder, except for support/MuscleSupport.h . See also the micromessage README.TXT file","title":"MicroMessage bare-bones C API"},{"location":"micromessage/","text":"MicroMessage C class (API) #include \"lang/c/micromessage/MicroMessage.h\" C-only implementation of the MUSCLE Message class Flattened-data format is 100% compatible with the C++ implementation (i.e. can be used to communicate with C++ based MUSCLE programs) Never uses the heap Never converts data from 'raw flattened bytes' to a MicroMessage object or back Inspecting a MicroMessage is done by directly reading the 'raw flattened bytes' from a byte-buffer. Constructing a MicroMessage is equivalent to directly writing the 'raw flattened bytes' into a byte-buffer. The only modification allowed to a MicroMessage is appending more data to it (random-access editing isn't supported) Useful for platforms that don't have a C++ compiler (or whose C++ compiler is too antiquated to compile the MUSCLE C++ codebase) Useful for very constrained (e.g. MMU-less) environments where you want to avoid heap fragmentation. Try compiling and running the *micro*.c programs in muscle/test (enter make to compile everything in the test folder, then run ./microchatclient and/or ./microreflectclient from the command line) Quick links to source code of relevant MUSCLE-by-example programs: muscle/test/microchatclient.c muscle/test/microreflectclient.c","title":"MicroMessage"},{"location":"micromessage/#micromessage-c-class-api","text":"#include \"lang/c/micromessage/MicroMessage.h\" C-only implementation of the MUSCLE Message class Flattened-data format is 100% compatible with the C++ implementation (i.e. can be used to communicate with C++ based MUSCLE programs) Never uses the heap Never converts data from 'raw flattened bytes' to a MicroMessage object or back Inspecting a MicroMessage is done by directly reading the 'raw flattened bytes' from a byte-buffer. Constructing a MicroMessage is equivalent to directly writing the 'raw flattened bytes' into a byte-buffer. The only modification allowed to a MicroMessage is appending more data to it (random-access editing isn't supported) Useful for platforms that don't have a C++ compiler (or whose C++ compiler is too antiquated to compile the MUSCLE C++ codebase) Useful for very constrained (e.g. MMU-less) environments where you want to avoid heap fragmentation. Try compiling and running the *micro*.c programs in muscle/test (enter make to compile everything in the test folder, then run ./microchatclient and/or ./microreflectclient from the command line) Quick links to source code of relevant MUSCLE-by-example programs: muscle/test/microchatclient.c muscle/test/microreflectclient.c","title":"MicroMessage C class (API)"},{"location":"micromessagegateway/","text":"MicroMessageGateway C class (API) #include \"lang/c/micromessage/MicroMessageGateway.h\" C-only implementation of the MUSCLE MessageIOGateway class Handles sending and receiving of flattened-Message-data over a TCP socket (or other transport layer, specified via function pointers) Never uses the heap Never converts data from 'raw flattened bytes' to a MicroMessageGateway object or back Try compiling and running the *micro*.c programs in muscle/test (enter make to compile everything in the test folder, then run ./microchatclient, and/or ./microreflectclient from the command line) Quick links to source code of relevant test programs: muscle/test/microchatclient.c muscle/test/microreflectclient.c","title":"MicroMessageGateway"},{"location":"micromessagegateway/#micromessagegateway-c-class-api","text":"#include \"lang/c/micromessage/MicroMessageGateway.h\" C-only implementation of the MUSCLE MessageIOGateway class Handles sending and receiving of flattened-Message-data over a TCP socket (or other transport layer, specified via function pointers) Never uses the heap Never converts data from 'raw flattened bytes' to a MicroMessageGateway object or back Try compiling and running the *micro*.c programs in muscle/test (enter make to compile everything in the test folder, then run ./microchatclient, and/or ./microreflectclient from the command line) Quick links to source code of relevant test programs: muscle/test/microchatclient.c muscle/test/microreflectclient.c","title":"MicroMessageGateway C class (API)"},{"location":"miscutilityfunctions/","text":"Misc. Utility Functions (API) #include \"util/MiscUtilityFunctions.h\" Various functions that didn't fit well anywhere else are kept here. ParseArgs() and ParseFile() parse a textual list of arguments (of the form key or key=value ) into a Message object for easy argument-parsing. The input can be in the form of a single string or a file. UnparseArgs() and UnparseFile() do the opposite -- converts a Message object's string fields back into a text-string that can be written to disk as a config file. ParseConnectArg() takes a String of the form \"hostname:port\" and parses out the hostname and port into separate fields. HandleStandardDaemonArgs() takes a Message of command line / config arguments and looks for common arguments to handle in the standard way (e.g. \"displaylevel=debug\", \"console\", \"nice\", etc) Crash() does what the name suggests it will do. BecomeDaemonProcess() transfers the current process into the background, detached it from its parent process/shell. SpawnDaemonProcess() spawns a child process that will run in the background as a fork()'d copy of the current process. NybbleizeData() converts binary data into an ASCII-compatible 4-bits-per-character \"safe\" string, for passing the data over non-binary-safe transports. DenybbleizeString() does the opposite. MemMem() looks for the first occurrence small binary sequence within a larger one. (Like strstr() , except for raw binary) PrintHexBytes() prints out the specified binary data, in a pretty hexadecimal format, annotated with an ASCII sidebar (useful for debugging) LogHexBytes() does the same thing as PrintHexBytes() , except the output goes to the log instead of just to stdout. HexBytesToAnnotatedString() does the same thing again, except the output is returned as a String instead of output anywhere. ParseHexBytes() reads a human-readable string containing hex printouts (e.g. \"1f 7e 26 35\") and returns the corresponding binary data as a ByteBufferRef . HexBytesToString() converts a raw binary sequence into a human-readable string (e.g. \"1f 7e 26 35\"), without any annotation. FileExists() , RenameFile() , CopyFile() , and DeleteFile() all do what their names suggest. Win32AllocateStdioConsole() opens a DOS prompt so that stdout output can be viewed (under Windows only; other platforms don't need this) GetSystemMemoryUsagePercentage() returns the percentage of the host computer's RAM that is currently in use. Quick links to source code of relevant MUSCLE-by-example programs: miscutilityfunctions/example_1_monotonic_clock.cpp miscutilityfunctions/example_2_calendar_misc.cpp miscutilityfunctions/example_3_hex_bytes.cpp","title":"MiscUtilityFunctions"},{"location":"miscutilityfunctions/#misc-utility-functions-api","text":"#include \"util/MiscUtilityFunctions.h\" Various functions that didn't fit well anywhere else are kept here. ParseArgs() and ParseFile() parse a textual list of arguments (of the form key or key=value ) into a Message object for easy argument-parsing. The input can be in the form of a single string or a file. UnparseArgs() and UnparseFile() do the opposite -- converts a Message object's string fields back into a text-string that can be written to disk as a config file. ParseConnectArg() takes a String of the form \"hostname:port\" and parses out the hostname and port into separate fields. HandleStandardDaemonArgs() takes a Message of command line / config arguments and looks for common arguments to handle in the standard way (e.g. \"displaylevel=debug\", \"console\", \"nice\", etc) Crash() does what the name suggests it will do. BecomeDaemonProcess() transfers the current process into the background, detached it from its parent process/shell. SpawnDaemonProcess() spawns a child process that will run in the background as a fork()'d copy of the current process. NybbleizeData() converts binary data into an ASCII-compatible 4-bits-per-character \"safe\" string, for passing the data over non-binary-safe transports. DenybbleizeString() does the opposite. MemMem() looks for the first occurrence small binary sequence within a larger one. (Like strstr() , except for raw binary) PrintHexBytes() prints out the specified binary data, in a pretty hexadecimal format, annotated with an ASCII sidebar (useful for debugging) LogHexBytes() does the same thing as PrintHexBytes() , except the output goes to the log instead of just to stdout. HexBytesToAnnotatedString() does the same thing again, except the output is returned as a String instead of output anywhere. ParseHexBytes() reads a human-readable string containing hex printouts (e.g. \"1f 7e 26 35\") and returns the corresponding binary data as a ByteBufferRef . HexBytesToString() converts a raw binary sequence into a human-readable string (e.g. \"1f 7e 26 35\"), without any annotation. FileExists() , RenameFile() , CopyFile() , and DeleteFile() all do what their names suggest. Win32AllocateStdioConsole() opens a DOS prompt so that stdout output can be viewed (under Windows only; other platforms don't need this) GetSystemMemoryUsagePercentage() returns the percentage of the host computer's RAM that is currently in use. Quick links to source code of relevant MUSCLE-by-example programs: miscutilityfunctions/example_1_monotonic_clock.cpp miscutilityfunctions/example_2_calendar_misc.cpp miscutilityfunctions/example_3_hex_bytes.cpp","title":"Misc. Utility Functions (API)"},{"location":"mutex/","text":"muscle::Mutex class (API) #include \"system/Mutex.h\" A recursive mutex, useful for synchronization in multithreaded programs Similar to: std::recursive_mutex , pthread_mutex_t , QMutex , CRITICAL_SECTION When compiled with C++11, it works as an inline wrapper around std::recursive_mutex . Otherwise, it will be an inline wrapper around the appropriate native API. Lock() method locks the Mutex, Unlock() unlocks it. Nested locking is okay (i.e. you can call Lock() twice in a row, as long as you later call Unlock() twice to unlock it) MutexGuard can be placed on the stack; its constructor will call Lock() , on the specified Mutex , and its destructor will call Unlock() (similar to std::lock_guard ) Mutex class compiles away to a no-op if -DMUSCLE_SINGLE_THREAD_ONLY is defined (i.e. if multithreading support is disabled) If -DMUSCLE_ENABLE_DEADLOCK_FINDER is defined, Lock() and Unlock() calls will leave breadcrumbs that can later be fed to the tests/deadlockfinder.cpp program, which will detect potential deadlocks in the locking patterns and tell you about them. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/mutex (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: mutex/example_1_basic_usage.cpp mutex/example_2_mutex_guard.cpp","title":"Mutex/MutexGuard"},{"location":"mutex/#musclemutex-class-api","text":"#include \"system/Mutex.h\" A recursive mutex, useful for synchronization in multithreaded programs Similar to: std::recursive_mutex , pthread_mutex_t , QMutex , CRITICAL_SECTION When compiled with C++11, it works as an inline wrapper around std::recursive_mutex . Otherwise, it will be an inline wrapper around the appropriate native API. Lock() method locks the Mutex, Unlock() unlocks it. Nested locking is okay (i.e. you can call Lock() twice in a row, as long as you later call Unlock() twice to unlock it) MutexGuard can be placed on the stack; its constructor will call Lock() , on the specified Mutex , and its destructor will call Unlock() (similar to std::lock_guard ) Mutex class compiles away to a no-op if -DMUSCLE_SINGLE_THREAD_ONLY is defined (i.e. if multithreading support is disabled) If -DMUSCLE_ENABLE_DEADLOCK_FINDER is defined, Lock() and Unlock() calls will leave breadcrumbs that can later be fed to the tests/deadlockfinder.cpp program, which will detect potential deadlocks in the locking patterns and tell you about them. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/mutex (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: mutex/example_1_basic_usage.cpp mutex/example_2_mutex_guard.cpp","title":"muscle::Mutex class (API)"},{"location":"naming-conventions/","text":"MUSCLE Naming Conventions #ifndef TheHeaderFileName_h #define TheHeaderFileName_h #include \"support/MuscleSupport.h\" namespace muscle { class ClassNamesAreInCamelCase { public: status_t MethodNamesAreInCamelCase(int parameterNamesAreLowerCamelCase) { int localVarsAreLowerCamelCase = 0; // On failure, prefer returning an error-code // (e.g. B_ERROR) over throwing an exception if (SomethingWentWrong()) return B_ERROR(\"Something bad happened\"); [...] return B_NO_ERROR; // returning B_NO_ERROR indicates success! } enum { COMPILE_TIME_CONSTANTS_ARE_ALL_UPPER_CASE }; private: int _memberVariablesStartWithAnUnderbar; }; extern int _staticAndGlobalVariablesAlsoStartWithAnUnderbar; }; // end namespace muscle #endif","title":"MUSCLE Naming Conventions"},{"location":"naming-conventions/#muscle-naming-conventions","text":"#ifndef TheHeaderFileName_h #define TheHeaderFileName_h #include \"support/MuscleSupport.h\" namespace muscle { class ClassNamesAreInCamelCase { public: status_t MethodNamesAreInCamelCase(int parameterNamesAreLowerCamelCase) { int localVarsAreLowerCamelCase = 0; // On failure, prefer returning an error-code // (e.g. B_ERROR) over throwing an exception if (SomethingWentWrong()) return B_ERROR(\"Something bad happened\"); [...] return B_NO_ERROR; // returning B_NO_ERROR indicates success! } enum { COMPILE_TIME_CONSTANTS_ARE_ALL_UPPER_CASE }; private: int _memberVariablesStartWithAnUnderbar; }; extern int _staticAndGlobalVariablesAlsoStartWithAnUnderbar; }; // end namespace muscle #endif","title":"MUSCLE Naming Conventions"},{"location":"nestcount/","text":"muscle::NestCount class (API) #include \"util/NestCount.h\" The NestCount class is a simple recursion-safe RAII counter mechanism for tracking a program's execution-state within a call tree. A NestCount object is typically declared as a member variable in a class, and a NestCountGuard object is declared at the top of a (potentially) recursive/re-entrant method in that class. Once that is done, the NestCount 's IsInBatch() method can be called at any time to find out if any NestCountGuard s referencing that NestCount are currently on the thread's stack. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/nestcount (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: nestcount/example_1_basic_usage.cpp nestcount/example_2_recursion_batch.cpp nestcount/example_3_without_guard.cpp","title":"NestCount/NestCountGuard"},{"location":"nestcount/#musclenestcount-class-api","text":"#include \"util/NestCount.h\" The NestCount class is a simple recursion-safe RAII counter mechanism for tracking a program's execution-state within a call tree. A NestCount object is typically declared as a member variable in a class, and a NestCountGuard object is declared at the top of a (potentially) recursive/re-entrant method in that class. Once that is done, the NestCount 's IsInBatch() method can be called at any time to find out if any NestCountGuard s referencing that NestCount are currently on the thread's stack. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/nestcount (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: nestcount/example_1_basic_usage.cpp nestcount/example_2_recursion_batch.cpp nestcount/example_3_without_guard.cpp","title":"muscle::NestCount class (API)"},{"location":"networkinterfaceinfo/","text":"muscle::NetworkInterfaceInfo class (API) #include \"util/NetworkInterfaceInfo.h\" Holds discovered information about a local network device (Ethernet card, Wi-Fi, etc) Similar to: QNetworkInterface Contains info like the NIC's name, human-readable description, MAC address, netmask, copper status, hardware type, etc. Call GetNetworkInterfaceInfos() (in the NetworkUtilityFunctions API ) to populate a Queue<NetworkInterfaceInfo> with all the info about the host computer's attached network interfaces A DetectNetworkConfigChangesSession object can optionally be used to notify your program whenever the local computer's network configuration has changed, in case it wants to respond to that (e.g. by reconnecting sockets) Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/networkinterfaceinfo (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: networkinterfaceinfo/example_1_basic_usage.cpp","title":"NetworkInterfaceInfo"},{"location":"networkinterfaceinfo/#musclenetworkinterfaceinfo-class-api","text":"#include \"util/NetworkInterfaceInfo.h\" Holds discovered information about a local network device (Ethernet card, Wi-Fi, etc) Similar to: QNetworkInterface Contains info like the NIC's name, human-readable description, MAC address, netmask, copper status, hardware type, etc. Call GetNetworkInterfaceInfos() (in the NetworkUtilityFunctions API ) to populate a Queue<NetworkInterfaceInfo> with all the info about the host computer's attached network interfaces A DetectNetworkConfigChangesSession object can optionally be used to notify your program whenever the local computer's network configuration has changed, in case it wants to respond to that (e.g. by reconnecting sockets) Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/networkinterfaceinfo (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: networkinterfaceinfo/example_1_basic_usage.cpp","title":"muscle::NetworkInterfaceInfo class (API)"},{"location":"networkutilityfunctions/","text":"Network Utility Functions (API) #include \"util/NetworkUtilityFunctions.h\" MUSCLE's user-friendly C++ wrapper around the BSD Sockets C API Uses ConstSocketRef (instead of int ) to represent file descriptors, to avoid any chance of file descriptor \"leaks\" Code written to this API will generally \"just work\" over both IPv4 and IPv6, no special-case code required. GetHostByName() returns the IPAddress associated with a given hostname. CreateUDPSocket() creates a UDP socket. BindUDPSocket() binds the UDP socket to a local port. Connect() returns a TCP socket that is connected to the specified host and port. CreateAcceptingSocket() returns a socket that can be used to accept TCP connections. Accept() accepts an incoming TCP connection and returns a ConstSocketRef representing the new connection. SendData() sends bytes over a TCP connection. SendDataUDP() sends bytes out via a UDP packet. ReceiveData() receives bytes over a TCP connection. ReceiveDataUDP() receives bytes from an incoming UDP packet. ... etc etc. Note that there is no CloseSocket() function, because it's not necessary. Sockets will automatically close themselves when their last ConstSocketRef goes away, via RAII-magic. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/networkutilityfunctions (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: networkutilityfunctions/example_1_tcp_client.cpp networkutilityfunctions/example_2_udp_pingpong.cpp networkutilityfunctions/example_3_udp_multicast.cpp","title":"NetworkUtilityFunctions"},{"location":"networkutilityfunctions/#network-utility-functions-api","text":"#include \"util/NetworkUtilityFunctions.h\" MUSCLE's user-friendly C++ wrapper around the BSD Sockets C API Uses ConstSocketRef (instead of int ) to represent file descriptors, to avoid any chance of file descriptor \"leaks\" Code written to this API will generally \"just work\" over both IPv4 and IPv6, no special-case code required. GetHostByName() returns the IPAddress associated with a given hostname. CreateUDPSocket() creates a UDP socket. BindUDPSocket() binds the UDP socket to a local port. Connect() returns a TCP socket that is connected to the specified host and port. CreateAcceptingSocket() returns a socket that can be used to accept TCP connections. Accept() accepts an incoming TCP connection and returns a ConstSocketRef representing the new connection. SendData() sends bytes over a TCP connection. SendDataUDP() sends bytes out via a UDP packet. ReceiveData() receives bytes over a TCP connection. ReceiveDataUDP() receives bytes from an incoming UDP packet. ... etc etc. Note that there is no CloseSocket() function, because it's not necessary. Sockets will automatically close themselves when their last ConstSocketRef goes away, via RAII-magic. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/networkutilityfunctions (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: networkutilityfunctions/example_1_tcp_client.cpp networkutilityfunctions/example_2_udp_pingpong.cpp networkutilityfunctions/example_3_udp_multicast.cpp","title":"Network Utility Functions (API)"},{"location":"nulldataio/","text":"muscle::NullDataIO class (API) #include \"dataio/NullDataIO.h\" NullDataIO is a no-op/dummy DataIO object that implements write-only memory. Any data passed to NullDataIO::Write() will be accepted and discarded. NullDataIO::Read() will always return 0 (unless Shutdown() has been called, in which case it will return -1/error) Useful for testing, or when you just don't care what happens to the data your gateway is generating. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/dataio (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file)","title":"NullDataIO"},{"location":"nulldataio/#musclenulldataio-class-api","text":"#include \"dataio/NullDataIO.h\" NullDataIO is a no-op/dummy DataIO object that implements write-only memory. Any data passed to NullDataIO::Write() will be accepted and discarded. NullDataIO::Read() will always return 0 (unless Shutdown() has been called, in which case it will return -1/error) Useful for testing, or when you just don't care what happens to the data your gateway is generating. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/dataio (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file)","title":"muscle::NullDataIO class (API)"},{"location":"otherlanguages/","text":"MUSCLE client-side API support for other languages MUSCLE expects most server-side code will be written in C++ (or possibly in C) However, it's a fact that client-side software is often written in many different languages Therefore, MUSCLE tries to provide explicit client-side support APIs for as many languages as possible. MUSCLE-speaking programs in any language should be able to communicate seamlessly with each other (since they all use the same flattened-Message binary-communication-protocol) Currently, MUSCLE has explicit client-side support for the following languages: C++03 and higher (with full features enabled under C++11 and higher) C (via the MicroMessage and MiniMessage APIs) C# (see the muscle/lang/csharp folder) Delphi (see the muscle/lang/delphi folder) Python (via the .py files in the muscle/lang/python2 folder or the muscle/lang/python3 folder) Java (via the files in the muscle/lang/java folder) Java 2 Micro Edition (via the files in the muscle/lang/java_j2me folder) Support for other languages is straightforward to add if/when necessary.","title":"Overview"},{"location":"otherlanguages/#muscle-client-side-api-support-for-other-languages","text":"MUSCLE expects most server-side code will be written in C++ (or possibly in C) However, it's a fact that client-side software is often written in many different languages Therefore, MUSCLE tries to provide explicit client-side support APIs for as many languages as possible. MUSCLE-speaking programs in any language should be able to communicate seamlessly with each other (since they all use the same flattened-Message binary-communication-protocol) Currently, MUSCLE has explicit client-side support for the following languages: C++03 and higher (with full features enabled under C++11 and higher) C (via the MicroMessage and MiniMessage APIs) C# (see the muscle/lang/csharp folder) Delphi (see the muscle/lang/delphi folder) Python (via the .py files in the muscle/lang/python2 folder or the muscle/lang/python3 folder) Java (via the files in the muscle/lang/java folder) Java 2 Micro Edition (via the files in the muscle/lang/java_j2me folder) Support for other languages is straightforward to add if/when necessary.","title":"MUSCLE client-side API support for other languages"},{"location":"packetdataio/","text":"muscle::PacketDataIO class (API) #include \"dataio/PacketDataIO.h\" PacketDataIO is an interface that extends the DataIO interface to handle UDP-style packet I/O. A PacketDataIO can do the usual Read() , Write() , etc, but also has the concept of packet-source and packet-destination addresses. This sub-interface adds WriteTo() and ReadFrom() methods to the DataIO API. This sub-interface also adds GetMaximumPacketSize() , GetSourceOfLastReadPacket() , and SetPacketSendDestination() methods to the DataIO API. Subclasses of PacketDataIO include UDPSocketDataIO , and SimulatedMulticastDataIO . Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/dataio (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: dataio/example_5_packet_dataio.cpp","title":"PacketDataIO"},{"location":"packetdataio/#musclepacketdataio-class-api","text":"#include \"dataio/PacketDataIO.h\" PacketDataIO is an interface that extends the DataIO interface to handle UDP-style packet I/O. A PacketDataIO can do the usual Read() , Write() , etc, but also has the concept of packet-source and packet-destination addresses. This sub-interface adds WriteTo() and ReadFrom() methods to the DataIO API. This sub-interface also adds GetMaximumPacketSize() , GetSourceOfLastReadPacket() , and SetPacketSendDestination() methods to the DataIO API. Subclasses of PacketDataIO include UDPSocketDataIO , and SimulatedMulticastDataIO . Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/dataio (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: dataio/example_5_packet_dataio.cpp","title":"muscle::PacketDataIO class (API)"},{"location":"plaintextmessageiogateway/","text":"muscle::PlainTextMessageIOGateway class (API) #include \"iogateway/PlainTextMessageIOGateway.h\" The PlainTextMessageIOGateway class communicates over the network via lines of plain old ASCII text. Incoming lines of plain text are added to Message objects via msg.AddString(PR_NAME_TEXT_LINE, \"the incoming text goes here\") , and these Messages are passed up to the gateway's user. Outgoing Message objects are examined, and if they contain a String field named PR_NAME_TEXT_LINE (aka \"tl\"), that text will be sent across the network. Carriage returns and newlines are automatically handled by the gateway. Note that (unlike MessageIOGateway ) this gateway won't losslessly transmit any arbitrary Message object; rather it only uses Messages as a carrier for text lines. Any other field names or data types (besides PR_NAME_TEXT_LINE / B_STRING_TYPE ) will be ignored. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/iogateway (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: example_3_text_to_file.cpp example_4_text_to_tcp.cpp","title":"PlainTextMessageIOGateway"},{"location":"plaintextmessageiogateway/#muscleplaintextmessageiogateway-class-api","text":"#include \"iogateway/PlainTextMessageIOGateway.h\" The PlainTextMessageIOGateway class communicates over the network via lines of plain old ASCII text. Incoming lines of plain text are added to Message objects via msg.AddString(PR_NAME_TEXT_LINE, \"the incoming text goes here\") , and these Messages are passed up to the gateway's user. Outgoing Message objects are examined, and if they contain a String field named PR_NAME_TEXT_LINE (aka \"tl\"), that text will be sent across the network. Carriage returns and newlines are automatically handled by the gateway. Note that (unlike MessageIOGateway ) this gateway won't losslessly transmit any arbitrary Message object; rather it only uses Messages as a carrier for text lines. Any other field names or data types (besides PR_NAME_TEXT_LINE / B_STRING_TYPE ) will be ignored. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/iogateway (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: example_3_text_to_file.cpp example_4_text_to_tcp.cpp","title":"muscle::PlainTextMessageIOGateway class (API)"},{"location":"proxydataio/","text":"muscle::ProxyDataIO class (API) #include \"dataio/ProxyDataIO.h\" ProxyDataIO is an interface that extends both the SeekableDataIO and PacketDataIO interfaces (using virtual inheritance). The purpose of the ProxyDataIO class is to serve as a base class for any \"decorator-style\" DataIO -subclass that wants to take an arbitrary existing DataIO object as an argument (typically by holding it via a DataIORef ) and dynamically modify its behavior by standing in between the DataIO object and the calling code. For a simple example, see the XorProxyDataIO class -- it is a decorator object that transparently adds a per-byte XOR transformation to the data going into (or coming out of) the DataIO object it holds. Another example use-case is the AsyncDataIO class, which executes the operations of its held DataIO object in a separate thread, so that they won't/can't ever slow down the calling thread (not even if the held DataIO is doing blocking I/O). A third example use-case is the PacketizedProxyDataIO class, which inserts framing-data into its child DataIO's data stream so that the data will be received on the receiving side in the same-sized chunks that it was sent on the sending-side (thus avoiding every TCP programmer's first trip to StackOverflow to ask why his recv() calls don't have a 1:1 correspondence to his send() calls) Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/dataio (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file)","title":"ProxyDataIO"},{"location":"proxydataio/#muscleproxydataio-class-api","text":"#include \"dataio/ProxyDataIO.h\" ProxyDataIO is an interface that extends both the SeekableDataIO and PacketDataIO interfaces (using virtual inheritance). The purpose of the ProxyDataIO class is to serve as a base class for any \"decorator-style\" DataIO -subclass that wants to take an arbitrary existing DataIO object as an argument (typically by holding it via a DataIORef ) and dynamically modify its behavior by standing in between the DataIO object and the calling code. For a simple example, see the XorProxyDataIO class -- it is a decorator object that transparently adds a per-byte XOR transformation to the data going into (or coming out of) the DataIO object it holds. Another example use-case is the AsyncDataIO class, which executes the operations of its held DataIO object in a separate thread, so that they won't/can't ever slow down the calling thread (not even if the held DataIO is doing blocking I/O). A third example use-case is the PacketizedProxyDataIO class, which inserts framing-data into its child DataIO's data stream so that the data will be received on the receiving side in the same-sized chunks that it was sent on the sending-side (thus avoiding every TCP programmer's first trip to StackOverflow to ask why his recv() calls don't have a 1:1 correspondence to his send() calls) Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/dataio (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file)","title":"muscle::ProxyDataIO class (API)"},{"location":"pulsenode/","text":"muscle::PulseNode class (API) #include \"util/PulseNode.h\" PulseNode is an interface inherited by classes that may want to get their Pulse() callback-method called at various times they specify via their GetPulseTime() method. An object that subclasses PulseNode may reimplement its GetPulseTime() method to return a time (in 64-bit GetRunTime64() -style microseconds) at which its Pulse() method should be called next (or it can return MUSCLE_TIME_NEVER if it doesn't currently want Pulse() to be called). At the scheduled time that was returned by GetPulseTime() (or very shortly thereafter) Pulse() will be called. This only works if the object is attached to event loop whose PulseNodeManager (typically the ReflectServer ) is implemented to perform the necessary Pulse() calls. If the object changes its mind about when Pulse() should be called next, it should call InvalidatePulseTime() to let the PulseNodeManager know it needs to call GetPulseTime() again to get the new next-pulse-scheduled-for time. (Exception: this isn't necessary inside Pulse() itself, since GetPulseTime() will always be called after a call to Pulse() ) Built-in classes that offer GetPulseTime() / Pulse() callbacks include: ReflectServer , ReflectSessionFactory , AbstractReflectSession , AbstractMessageIOGateway , AbstractSessionIOPolicy When reimplementing GetPulseTime() and Pulse() , be sure to call up to the parent class's implementation of those methods in order not to break the parent-class's internal Pulse-callback-functionality. (Combine your GetPulseTime() return-value with the superclass-method's return-value by returning the minimum of the two values (e.g. via muscleMin() or std::min() )) If a subclass of PulseNode wants to offer PulseNodeManager -style GetPulseTime() / Pulse() service to other objects that it owns, it can do so easily, just by subclassing those objects from PulseNode as well, and calling PutPulseChild() on each object once, to add the object to its PulseNodeManager 's callback-list. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/reflector (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: reflector/example_6_smart_server_with_pulsenode.cpp reflector/example_7_smart_server_with_udp_pingpong.cpp","title":"PulseNode"},{"location":"pulsenode/#musclepulsenode-class-api","text":"#include \"util/PulseNode.h\" PulseNode is an interface inherited by classes that may want to get their Pulse() callback-method called at various times they specify via their GetPulseTime() method. An object that subclasses PulseNode may reimplement its GetPulseTime() method to return a time (in 64-bit GetRunTime64() -style microseconds) at which its Pulse() method should be called next (or it can return MUSCLE_TIME_NEVER if it doesn't currently want Pulse() to be called). At the scheduled time that was returned by GetPulseTime() (or very shortly thereafter) Pulse() will be called. This only works if the object is attached to event loop whose PulseNodeManager (typically the ReflectServer ) is implemented to perform the necessary Pulse() calls. If the object changes its mind about when Pulse() should be called next, it should call InvalidatePulseTime() to let the PulseNodeManager know it needs to call GetPulseTime() again to get the new next-pulse-scheduled-for time. (Exception: this isn't necessary inside Pulse() itself, since GetPulseTime() will always be called after a call to Pulse() ) Built-in classes that offer GetPulseTime() / Pulse() callbacks include: ReflectServer , ReflectSessionFactory , AbstractReflectSession , AbstractMessageIOGateway , AbstractSessionIOPolicy When reimplementing GetPulseTime() and Pulse() , be sure to call up to the parent class's implementation of those methods in order not to break the parent-class's internal Pulse-callback-functionality. (Combine your GetPulseTime() return-value with the superclass-method's return-value by returning the minimum of the two values (e.g. via muscleMin() or std::min() )) If a subclass of PulseNode wants to offer PulseNodeManager -style GetPulseTime() / Pulse() service to other objects that it owns, it can do so easily, just by subclassing those objects from PulseNode as well, and calling PutPulseChild() on each object once, to add the object to its PulseNodeManager 's callback-list. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/reflector (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: reflector/example_6_smart_server_with_pulsenode.cpp reflector/example_7_smart_server_with_udp_pingpong.cpp","title":"muscle::PulseNode class (API)"},{"location":"qmessagetransceiverthread/","text":"muscle::QMessageTransceiverThread class (API) #include \"platform/qt/QMessageTransceiverThread.h\" QMessageTransceiverThread is a Qt-specific subclass of MessageTransceiverThread . It adds some glue code, so that incoming events emit Qt signals (so no need to call MessageTransceiverThread::GetNextEventFromInternalThread() manually, instead just connect() the appropriate signals from the QMessageTransceiverThread object to the appropriate slots in your Qt/GUI object(s)) Try compiling and running the mini-example-program in muscle/platform/qt/qt_example (enter qmake; make to compile qt_example.app, and then run qt_example.app from Terminal or via its icon. See the README.txt in that folder for more details) Quick links to source code of relevant test programs: muscle/platform/qt/qt_example/qt_example.cpp muscle/platform/qt/qt_example/qt_example.h muscle/platform/qt/qt_muscled_browser/Browser.cpp muscle/platform/qt/qt_muscled_browser/Browser.h","title":"QMessageTransceiverThread"},{"location":"qmessagetransceiverthread/#muscleqmessagetransceiverthread-class-api","text":"#include \"platform/qt/QMessageTransceiverThread.h\" QMessageTransceiverThread is a Qt-specific subclass of MessageTransceiverThread . It adds some glue code, so that incoming events emit Qt signals (so no need to call MessageTransceiverThread::GetNextEventFromInternalThread() manually, instead just connect() the appropriate signals from the QMessageTransceiverThread object to the appropriate slots in your Qt/GUI object(s)) Try compiling and running the mini-example-program in muscle/platform/qt/qt_example (enter qmake; make to compile qt_example.app, and then run qt_example.app from Terminal or via its icon. See the README.txt in that folder for more details) Quick links to source code of relevant test programs: muscle/platform/qt/qt_example/qt_example.cpp muscle/platform/qt/qt_example/qt_example.h muscle/platform/qt/qt_muscled_browser/Browser.cpp muscle/platform/qt/qt_muscled_browser/Browser.h","title":"muscle::QMessageTransceiverThread class (API)"},{"location":"queryfilter/","text":"muscle::QueryFilter class (API) #include \"regex/QueryFilter.h\" A boolean-test object for limiting MUSCLE queries by their value-results. The main purpose for a QueryFilter object is to constrain a MUSCLE database-node subscription so that only nodes whose Message objects match specified criteria will be returned. That way if a client is only interested in certain nodes, the filtering can be done on the server-side to save bandwidth. A QueryFilter represents a pass/fail test that can be applied to a Message object Given a particular Message object, the Matches() method of a QueryFilter can return true or false. QueryFilter objects have SaveToArchive() and SetFromArchive() methods defined, so that they can be transported across the network. QueryFilters can be composed into groups (using e.g. AndQueryFilter or OrQueryFilter ) to represent arbitrarily complex boolean expressions. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/queryfilter (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: queryfilter/example_1_basic_usage.cpp queryfilter/example_2_smart_client_with_queryfilter.cpp","title":"QueryFilter"},{"location":"queryfilter/#musclequeryfilter-class-api","text":"#include \"regex/QueryFilter.h\" A boolean-test object for limiting MUSCLE queries by their value-results. The main purpose for a QueryFilter object is to constrain a MUSCLE database-node subscription so that only nodes whose Message objects match specified criteria will be returned. That way if a client is only interested in certain nodes, the filtering can be done on the server-side to save bandwidth. A QueryFilter represents a pass/fail test that can be applied to a Message object Given a particular Message object, the Matches() method of a QueryFilter can return true or false. QueryFilter objects have SaveToArchive() and SetFromArchive() methods defined, so that they can be transported across the network. QueryFilters can be composed into groups (using e.g. AndQueryFilter or OrQueryFilter ) to represent arbitrarily complex boolean expressions. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/queryfilter (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: queryfilter/example_1_basic_usage.cpp queryfilter/example_2_smart_client_with_queryfilter.cpp","title":"muscle::QueryFilter class (API)"},{"location":"queue/","text":"muscle::Queue class (API) #include \"util/Queue.h\" Templated container class Queue<T> is a bidirectional variable-sized vector/queue/ring-buffer, implemented using an internal array and modulo-based index-arithmetic Similar to: std::deque<T> , std::vector<T> , std::queue<T> , std::stack<T> , QVector O(1) item-get/item-set (via [] operator or GetItemAt() / ReplaceItemAt() ) O(1) AddTail(const ItemType &) (analogous to push_back() ) O(1) RemoveTail(const ItemType &) (analogous to pop_back() ) O(1) AddHead(const ItemType &) (analogous to push_front() ) O(1) RemoveHead(const ItemType &) (analogous to pop_front() ) O(N*log(N)) Sort() O(N) RemoveItemAt() / InsertItemAt() / InsertItemsAt() O(1) SwapContents() This class is typically used when an expandable-array is desired ( std::vector<T> -style), or an efficient FIFO-queue/ring-buffer is desired ( std::deque<T> -style). Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/queue (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: queue/example_1_basic_usage.cpp queue/example_2_sorting.cpp queue/example_3_idioms.cpp","title":"Queue"},{"location":"queue/#musclequeue-class-api","text":"#include \"util/Queue.h\" Templated container class Queue<T> is a bidirectional variable-sized vector/queue/ring-buffer, implemented using an internal array and modulo-based index-arithmetic Similar to: std::deque<T> , std::vector<T> , std::queue<T> , std::stack<T> , QVector O(1) item-get/item-set (via [] operator or GetItemAt() / ReplaceItemAt() ) O(1) AddTail(const ItemType &) (analogous to push_back() ) O(1) RemoveTail(const ItemType &) (analogous to pop_back() ) O(1) AddHead(const ItemType &) (analogous to push_front() ) O(1) RemoveHead(const ItemType &) (analogous to pop_front() ) O(N*log(N)) Sort() O(N) RemoveItemAt() / InsertItemAt() / InsertItemsAt() O(1) SwapContents() This class is typically used when an expandable-array is desired ( std::vector<T> -style), or an efficient FIFO-queue/ring-buffer is desired ( std::deque<T> -style). Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/queue (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: queue/example_1_basic_usage.cpp queue/example_2_sorting.cpp queue/example_3_idioms.cpp","title":"muscle::Queue class (API)"},{"location":"ratelimitsessioniopolicy/","text":"muscle::RateLimitSessionIOPolicy class (API) #include \"reflector/RateLimitSessionIOPolicy.h\" RateLimitSessionIOPolicy is an AbstractSessionIOPolicy that you can install on a session to cap its incoming- and/or outgoing-bandwidth usage to a set maximum. You can install a separate RateLimitSessionIOPolicy on each session in order to implement a per-session bandwidth cap Alternatively, you could instantiate a single RateLimitSessionIOPolicy object and install it on all sessions to enforce a cumulative bandwidth cap across the whole ReflectServer . Or you could aim somewhere in the middle, with certain groups of sessions sharing a bandwidth cap while other sessions operate freely (or etc). Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/reflector (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file)","title":"RateLimitSessionIOPolicy"},{"location":"ratelimitsessioniopolicy/#muscleratelimitsessioniopolicy-class-api","text":"#include \"reflector/RateLimitSessionIOPolicy.h\" RateLimitSessionIOPolicy is an AbstractSessionIOPolicy that you can install on a session to cap its incoming- and/or outgoing-bandwidth usage to a set maximum. You can install a separate RateLimitSessionIOPolicy on each session in order to implement a per-session bandwidth cap Alternatively, you could instantiate a single RateLimitSessionIOPolicy object and install it on all sessions to enforce a cumulative bandwidth cap across the whole ReflectServer . Or you could aim somewhere in the middle, with certain groups of sessions sharing a bandwidth cap while other sessions operate freely (or etc). Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/reflector (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file)","title":"muscle::RateLimitSessionIOPolicy class (API)"},{"location":"rawdatamessageiogateway/","text":"muscle::RawDataMessageIOGateway class (API) #include \"iogateway/RawDataMessageIOGateway.h\" The RawDataMessageIOGateway class transmits raw binary data across the network. This class is useful if you don't want to attempt any data-parsing at the gateway level, but just want the raw bytes delivered verbatim to your higher-level code. Incoming bytes of binary data added to Message objects via msg.AddData(PR_NAME_DATA_CHUNKS, B_RAW_TYPE, pointerToBytes, numBytes) , and these Messages are passed up to the gateway's user. No framing logic is attempted, so the sizes of the \"chunks\" of raw data will be largely indeterminate (although you can specify a minimum and maximum chunk-size in the RawDataMessageIOGateway constructor, if you want to) Outgoing Message objects are examined, and if they contain a B_RAW_TYPE field named PR_NAME_DATA_CHUNKS (aka \"rd\"), those bytes will be sent across the network. CountedRawDataMessageIOGateway is the same as RawDataMessageIOGateway except that it keeps a running tally of the number of bytes currently present in its outgoing-Messages-queue. This can be handy if you want to monitor/limit the memory footprint of that queue. Note that (unlike MessageIOGateway ) this gateway won't losslessly transmit any arbitrary Message object; rather it only uses Messages as a carrier for binary data. Any other field names or data types (besides PR_NAME_DATA_CHUNKS / B_RAW_TYPE ) will be ignored. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/iogateway (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: reflector/example_7_smart_server_with_udp_pingpong.cpp","title":"RawDataMessageIOGateway"},{"location":"rawdatamessageiogateway/#musclerawdatamessageiogateway-class-api","text":"#include \"iogateway/RawDataMessageIOGateway.h\" The RawDataMessageIOGateway class transmits raw binary data across the network. This class is useful if you don't want to attempt any data-parsing at the gateway level, but just want the raw bytes delivered verbatim to your higher-level code. Incoming bytes of binary data added to Message objects via msg.AddData(PR_NAME_DATA_CHUNKS, B_RAW_TYPE, pointerToBytes, numBytes) , and these Messages are passed up to the gateway's user. No framing logic is attempted, so the sizes of the \"chunks\" of raw data will be largely indeterminate (although you can specify a minimum and maximum chunk-size in the RawDataMessageIOGateway constructor, if you want to) Outgoing Message objects are examined, and if they contain a B_RAW_TYPE field named PR_NAME_DATA_CHUNKS (aka \"rd\"), those bytes will be sent across the network. CountedRawDataMessageIOGateway is the same as RawDataMessageIOGateway except that it keeps a running tally of the number of bytes currently present in its outgoing-Messages-queue. This can be handy if you want to monitor/limit the memory footprint of that queue. Note that (unlike MessageIOGateway ) this gateway won't losslessly transmit any arbitrary Message object; rather it only uses Messages as a carrier for binary data. Any other field names or data types (besides PR_NAME_DATA_CHUNKS / B_RAW_TYPE ) will be ignored. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/iogateway (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: reflector/example_7_smart_server_with_udp_pingpong.cpp","title":"muscle::RawDataMessageIOGateway class (API)"},{"location":"refcount/","text":"muscle::RefCountable class (API) #include \"util/RefCount.h\" Reference-counting for heap-allocated objects, to makes memory-leaks and use-after-free errors nearly impossible. Similar to: std::shared_ptr<T> , boost::intrusive_ptr<T> , QSharedPointer Object to be reference-counted must be a subclass of RefCountable . The ref-counted object will always be deleted by the destructor of the last Ref that points to it -- explicitly calling delete is NEVER necessary! Often used in conjunction with the ObjectPool class to recycle used objects (to minimize heap allocations/deallocations) Idiom: For any RefCountable class FooBar , the DECLARE_REFTYPES() macro defines typedefs FooBarRef and ConstFooBarRef : class FooBar : public RefCountable { [...] }; DECLARE_REFTYPES(FooBar); // macro to define FooBarRef and ConstFooBarRef types FooBarRef oneRef(new FooBar); // same as Ref<FooBar> oneRef(new FooBar); ConstFooBarRef twoRef(new FooBar); // same as ConstRef<FooBar> twoRef(new FooBar); twoRef()->Hello(); // () operator gives pointer to RefCountable object Ref is similar to a read/write shared-pointer, ConstRef is similar to a read-only shared-pointer. RefCountable uses an AtomicCounter internally for its ref-count, and ObjectPools are thread-safe, so it's safe to pass Ref and ConstRef objects around to different threads. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/refcount (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: refcount/example_1_basic_usage.cpp refcount/example_2_with_object_pool.cpp refcount/example_3_conversions.cpp refcount/example_4_dummy_refs.cpp","title":"Ref/RefCountable"},{"location":"refcount/#musclerefcountable-class-api","text":"#include \"util/RefCount.h\" Reference-counting for heap-allocated objects, to makes memory-leaks and use-after-free errors nearly impossible. Similar to: std::shared_ptr<T> , boost::intrusive_ptr<T> , QSharedPointer Object to be reference-counted must be a subclass of RefCountable . The ref-counted object will always be deleted by the destructor of the last Ref that points to it -- explicitly calling delete is NEVER necessary! Often used in conjunction with the ObjectPool class to recycle used objects (to minimize heap allocations/deallocations) Idiom: For any RefCountable class FooBar , the DECLARE_REFTYPES() macro defines typedefs FooBarRef and ConstFooBarRef : class FooBar : public RefCountable { [...] }; DECLARE_REFTYPES(FooBar); // macro to define FooBarRef and ConstFooBarRef types FooBarRef oneRef(new FooBar); // same as Ref<FooBar> oneRef(new FooBar); ConstFooBarRef twoRef(new FooBar); // same as ConstRef<FooBar> twoRef(new FooBar); twoRef()->Hello(); // () operator gives pointer to RefCountable object Ref is similar to a read/write shared-pointer, ConstRef is similar to a read-only shared-pointer. RefCountable uses an AtomicCounter internally for its ref-count, and ObjectPools are thread-safe, so it's safe to pass Ref and ConstRef objects around to different threads. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/refcount (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: refcount/example_1_basic_usage.cpp refcount/example_2_with_object_pool.cpp refcount/example_3_conversions.cpp refcount/example_4_dummy_refs.cpp","title":"muscle::RefCountable class (API)"},{"location":"reflectserver/","text":"muscle::ReflectServer class (API) #include \"reflector/ReflectServer.h\" ReflectServer implements a general-purpose event-loop for all the other MUSCLE components to live in. Similar to: QApplication , QEventLoop , ACE::Reactor A typical MUSCLE server program would put a ReflectServer object on the stack in main(), add one or more ServerComponent objects to it, then call ServerProcessLoop() on the ReflectServer . ServerProcessLoop() will typically not return until it is time for the program to exit. ServerProcessLoop() uses a SocketMultiplexer internally to handle I/O operations and calls callback methods on the attached ServerComponent objects at the appropriate times. The ReflectServer also handles the role of a PulseNodeManager , with ServerProcessLoop() calling Pulse() on its attached objects at the time(s) they have requested to have their Pulse() method called. ServerComponent object subclasses include ReflectSessionFactory objects (for accepting incoming TCP connections) and AbstractReflectSession objects (for handling the I/O and state associated with a single file descriptor or socket) More complex MUSCLE programs might have multiple threads, many with a separate ReflectServer object for each thread's event-loop. The MessageTransceiverThread class, in particular, does this. A thread's ReflectServer::ServerProcessLoop() call won't return until it is time for the thread to exit. New session objects can be added to the ReflectServer by calling AddNewSession() (either on the ReflectServer or on an already-attached session-object). New session objects that want to represent an outgoing TCP connection can be added to the ReflectServer by calling AddNewConnectSession() . The TCP connect will be done asynchronously (using a non-blocking connect) so it won't hold off the event loop. New ReflectSessionFactory objects can be added to the server by calling PutAcceptFactory() . Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/reflector (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: reflector/example_1_dumb_server.cpp reflector/example_2_dumb_client.cpp reflector/example_3_annotated_dumb_server.cpp reflector/example_4_smart_server.cpp reflector/example_5_smart_client.cpp reflector/example_6_smart_server_with_pulsenode.cpp reflector/example_7_smart_server_with_udp_pingpong.cpp","title":"ReflectServer"},{"location":"reflectserver/#musclereflectserver-class-api","text":"#include \"reflector/ReflectServer.h\" ReflectServer implements a general-purpose event-loop for all the other MUSCLE components to live in. Similar to: QApplication , QEventLoop , ACE::Reactor A typical MUSCLE server program would put a ReflectServer object on the stack in main(), add one or more ServerComponent objects to it, then call ServerProcessLoop() on the ReflectServer . ServerProcessLoop() will typically not return until it is time for the program to exit. ServerProcessLoop() uses a SocketMultiplexer internally to handle I/O operations and calls callback methods on the attached ServerComponent objects at the appropriate times. The ReflectServer also handles the role of a PulseNodeManager , with ServerProcessLoop() calling Pulse() on its attached objects at the time(s) they have requested to have their Pulse() method called. ServerComponent object subclasses include ReflectSessionFactory objects (for accepting incoming TCP connections) and AbstractReflectSession objects (for handling the I/O and state associated with a single file descriptor or socket) More complex MUSCLE programs might have multiple threads, many with a separate ReflectServer object for each thread's event-loop. The MessageTransceiverThread class, in particular, does this. A thread's ReflectServer::ServerProcessLoop() call won't return until it is time for the thread to exit. New session objects can be added to the ReflectServer by calling AddNewSession() (either on the ReflectServer or on an already-attached session-object). New session objects that want to represent an outgoing TCP connection can be added to the ReflectServer by calling AddNewConnectSession() . The TCP connect will be done asynchronously (using a non-blocking connect) so it won't hold off the event loop. New ReflectSessionFactory objects can be added to the server by calling PutAcceptFactory() . Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/reflector (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: reflector/example_1_dumb_server.cpp reflector/example_2_dumb_client.cpp reflector/example_3_annotated_dumb_server.cpp reflector/example_4_smart_server.cpp reflector/example_5_smart_client.cpp reflector/example_6_smart_server_with_pulsenode.cpp reflector/example_7_smart_server_with_udp_pingpong.cpp","title":"muscle::ReflectServer class (API)"},{"location":"reflectsessionfactory/","text":"muscle::ReflectSessionFactory class (API) #include \"reflector/AbstractReflectSessionFactory.h\" ReflectSessionFactory is a factory object that listens on a TCP port for incoming TCP connections. When an incoming TCP connection arrives, the factory's CreateSession() method is called. CreateSession() 's job is to create and return a new session object (e.g. a subclass of AbstractReflectSession ) that will be used to handle the new TCP connection's needs. If CreateSession() returns a valid reference, then the new session object is attached to the ReflectServer and used. Or if CreateSession() returns a NULL reference, the incoming TCP connection is denied and the TCP socket closed. Existing subclasses of ReflectSessionFactory include StorageReflectSessionFactory (creates StorageReflectSession objects), DumbReflectSessionFactory (creates DumbReflectSession objects), FilterSessionFactory (proxy/decorator factory that allows/denies incoming TCP connections based on their source IP address), etc. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/reflector (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: reflector/example_1_dumb_server.cpp reflector/example_3_annotated_dumb_server.cpp reflector/example_4_smart_server.cpp","title":"ReflectSessionFactory"},{"location":"reflectsessionfactory/#musclereflectsessionfactory-class-api","text":"#include \"reflector/AbstractReflectSessionFactory.h\" ReflectSessionFactory is a factory object that listens on a TCP port for incoming TCP connections. When an incoming TCP connection arrives, the factory's CreateSession() method is called. CreateSession() 's job is to create and return a new session object (e.g. a subclass of AbstractReflectSession ) that will be used to handle the new TCP connection's needs. If CreateSession() returns a valid reference, then the new session object is attached to the ReflectServer and used. Or if CreateSession() returns a NULL reference, the incoming TCP connection is denied and the TCP socket closed. Existing subclasses of ReflectSessionFactory include StorageReflectSessionFactory (creates StorageReflectSession objects), DumbReflectSessionFactory (creates DumbReflectSession objects), FilterSessionFactory (proxy/decorator factory that allows/denies incoming TCP connections based on their source IP address), etc. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/reflector (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: reflector/example_1_dumb_server.cpp reflector/example_3_annotated_dumb_server.cpp reflector/example_4_smart_server.cpp","title":"muscle::ReflectSessionFactory class (API)"},{"location":"rs232dataio/","text":"muscle::RS232DataIO class (API) #include \"dataio/RS232DataIO.h\" RS232DataIO is used to read/write data to/from a serial port. The port to use and baud rate can be specified. Works with select() / SocketMultiplexer (even under Windows!) RS232DataIO::GetAvailableSerialPortNames() provides a list of available serial ports. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/dataio (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file)","title":"RS232DataIO"},{"location":"rs232dataio/#musclers232dataio-class-api","text":"#include \"dataio/RS232DataIO.h\" RS232DataIO is used to read/write data to/from a serial port. The port to use and baud rate can be specified. Works with select() / SocketMultiplexer (even under Windows!) RS232DataIO::GetAvailableSerialPortNames() provides a list of available serial ports. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/dataio (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file)","title":"muscle::RS232DataIO class (API)"},{"location":"seekabledataio/","text":"muscle::SeekableDataIO class (API) #include \"dataio/SeekableDataIO.h\" SeekableDataIO is an interface that extends the DataIO interface to handle seekable devices. A SeekableDataIO can do the usual Read() , Write() , etc, but also has the concept of a seekable-head-position within whatever file (or file-like object) it is reading/writing. This sub-interface adds Seek() , GetPosition() , and GetLength() methods to the DataIO API. Subclasses of SeekableDataIO include FileDataIO , FileDescriptorDataIO , and ByteBufferDataIO . Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/dataio (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: dataio/example_1_basic_usage.cpp dataio/example_3_seekable_dataio.cpp dataio/example_4_idioms.cpp","title":"SeekableDataIO"},{"location":"seekabledataio/#muscleseekabledataio-class-api","text":"#include \"dataio/SeekableDataIO.h\" SeekableDataIO is an interface that extends the DataIO interface to handle seekable devices. A SeekableDataIO can do the usual Read() , Write() , etc, but also has the concept of a seekable-head-position within whatever file (or file-like object) it is reading/writing. This sub-interface adds Seek() , GetPosition() , and GetLength() methods to the DataIO API. Subclasses of SeekableDataIO include FileDataIO , FileDescriptorDataIO , and ByteBufferDataIO . Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/dataio (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: dataio/example_1_basic_usage.cpp dataio/example_3_seekable_dataio.cpp dataio/example_4_idioms.cpp","title":"muscle::SeekableDataIO class (API)"},{"location":"sharedmemory/","text":"muscle::SharedMemory class (API) #include \"system/SharedMemory.h\" An OS-neutral API for creating and accessing a shared-memory region. Used to share memory across multiple processes The shared memory region is accessed by an agreed-upon globally-unique name, which is passed in to the SetArea() method by each participating process. A SharedMemory object also includes a cross-process reader/writer lock to help synchronize access to the shared data. Multiple processes may lock the shared memory area for reading simultaneously (via LockAreaReadOnly() ) Only one process may lock the shared memory area for writing at a time (via LockAreaReadWrite() ) LockAreaReadWrite() won't return until all other locks (both readers' and writers') have been released. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/sharedmemory (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: sharedmemory/example_1_basic_usage.cpp","title":"SharedMemory"},{"location":"sharedmemory/#musclesharedmemory-class-api","text":"#include \"system/SharedMemory.h\" An OS-neutral API for creating and accessing a shared-memory region. Used to share memory across multiple processes The shared memory region is accessed by an agreed-upon globally-unique name, which is passed in to the SetArea() method by each participating process. A SharedMemory object also includes a cross-process reader/writer lock to help synchronize access to the shared data. Multiple processes may lock the shared memory area for reading simultaneously (via LockAreaReadOnly() ) Only one process may lock the shared memory area for writing at a time (via LockAreaReadWrite() ) LockAreaReadWrite() won't return until all other locks (both readers' and writers') have been released. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/sharedmemory (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: sharedmemory/example_1_basic_usage.cpp","title":"muscle::SharedMemory class (API)"},{"location":"signalhandlersession/","text":"muscle::SignalHandlerSession class (API) #include \"reflector/SignalHandlerSession.h\" SignalHandlerSession is an OS-neutral mechanism for catching and reacting to asynchronous signal events. This session can be added to your ReflectServer if you want to react to Unix-style signals (SIGINT/SIGHUP/etc) or Windows console events (CTRL_CLOSE_EVENT/CTRL_LOGOFF_EVENT/etc) The easiest way to enable it is just to call muscle::SetMainReflectServerCatchSignals(true) before starting your main thread's event loop. Then ReflectServer::ServerProcessLoop() will add a SignalHandlerSession internally that causes ReflectServer::ServerProcessLoop() to return when SIGINT/etc is received. You can also manually add a SignalHandlerSession to the ReflectServer if you want to implement your own custom handling. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/signalhandlersession (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: signalhandlersession/example_1_basic_usage.cpp signalhandlersession/example_2_custom_handling.cpp","title":"SignalHandlerSession"},{"location":"signalhandlersession/#musclesignalhandlersession-class-api","text":"#include \"reflector/SignalHandlerSession.h\" SignalHandlerSession is an OS-neutral mechanism for catching and reacting to asynchronous signal events. This session can be added to your ReflectServer if you want to react to Unix-style signals (SIGINT/SIGHUP/etc) or Windows console events (CTRL_CLOSE_EVENT/CTRL_LOGOFF_EVENT/etc) The easiest way to enable it is just to call muscle::SetMainReflectServerCatchSignals(true) before starting your main thread's event loop. Then ReflectServer::ServerProcessLoop() will add a SignalHandlerSession internally that causes ReflectServer::ServerProcessLoop() to return when SIGINT/etc is received. You can also manually add a SignalHandlerSession to the ReflectServer if you want to implement your own custom handling. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/signalhandlersession (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: signalhandlersession/example_1_basic_usage.cpp signalhandlersession/example_2_custom_handling.cpp","title":"muscle::SignalHandlerSession class (API)"},{"location":"signalmessageiogateway/","text":"muscle::SignalMessageIOGateway class (API) #include \"iogateway/SignalMessageIOGateway.h\" SignalMessageIOGateway is a \"dummy gateway\" used solely for thread-to-thread signalling purposes. This gateway isn't really used to transmit data; instead it is only used to send \"nudges\" Whenever one or more Message objects are sent to this gateway by its owner, this gateway will push a single 'notification byte' to its DataIO object. Whenever one or more bytes are received from the DataIO object, this gateway will pass a single 'notification Message ' up to its owning session. This gateway is used primarily for inter-thread communication (specifically, the internal thread of a Thread object sends a notification-message to the master thread telling it to go ahead and check its reply-Queue for new Messages , and vice-versa ). The actual inter-thread Message data itself is never sent through the gateway, since Message serialization/deserialization is an unnecessary and avoidable expense when communicating between two threads in the same process. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/iogateway (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: thread/example_2_dumb_server_with_thread.cpp","title":"SignalMessageIOGateway"},{"location":"signalmessageiogateway/#musclesignalmessageiogateway-class-api","text":"#include \"iogateway/SignalMessageIOGateway.h\" SignalMessageIOGateway is a \"dummy gateway\" used solely for thread-to-thread signalling purposes. This gateway isn't really used to transmit data; instead it is only used to send \"nudges\" Whenever one or more Message objects are sent to this gateway by its owner, this gateway will push a single 'notification byte' to its DataIO object. Whenever one or more bytes are received from the DataIO object, this gateway will pass a single 'notification Message ' up to its owning session. This gateway is used primarily for inter-thread communication (specifically, the internal thread of a Thread object sends a notification-message to the master thread telling it to go ahead and check its reply-Queue for new Messages , and vice-versa ). The actual inter-thread Message data itself is never sent through the gateway, since Message serialization/deserialization is an unnecessary and avoidable expense when communicating between two threads in the same process. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/iogateway (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: thread/example_2_dumb_server_with_thread.cpp","title":"muscle::SignalMessageIOGateway class (API)"},{"location":"simulatedmulticastdataio/","text":"muscle::SimulatedMulticastDataIO class (API) #include \"dataio/SimulatedMulticastDataIO.h\" SimulatedMulticastDataIO works similarly to UDPSocketDataIO , but it is written specifically to simulate multicast-UDP traffic over Wi-Fi using directed unicast. Transmitting any non-trivial amount of real multicast traffic over Wi-Fi is problematic, because Wi-Fi's multicast support sucks (it's really slow, lossy, and inefficient) SimulatedMulticastDataIO simulates multicast transmission by automatically maintaining a list of which other SimulatedMulticastDataIO -based clients are on the LAN (and using the same multicast address). When a client wants to \"multicast\" a packet, SimulatedMulticastDataIO::Write() instead sends packet separately to each group-member, via unicast UDP. To the calling code, this all looks the same as real multicast, but works better over Wi-Fi (it will generally be less efficient than actual multicast on a wired network though). See also NetworkInterfaceInfo::GetHardwareType() (and in particular, when that method returns NETWORK_INTERFACE_HARDWARE_TYPE_WIFI you might want to use this class instead of UDPSocketDataIO for your multicast traffic over that interface) Note that SimulatedMulticastDataIO uses its own proprietary discovery/enumeration protocol, so in general it is only useful for communicating with other programs that are also using a SimulatedMulticastDataIO object. In particular, it won't interact properly with third-party multicast-clients that don't know about its discovery-protocol. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/dataio (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file)","title":"SimulatedMulticastDataIO"},{"location":"simulatedmulticastdataio/#musclesimulatedmulticastdataio-class-api","text":"#include \"dataio/SimulatedMulticastDataIO.h\" SimulatedMulticastDataIO works similarly to UDPSocketDataIO , but it is written specifically to simulate multicast-UDP traffic over Wi-Fi using directed unicast. Transmitting any non-trivial amount of real multicast traffic over Wi-Fi is problematic, because Wi-Fi's multicast support sucks (it's really slow, lossy, and inefficient) SimulatedMulticastDataIO simulates multicast transmission by automatically maintaining a list of which other SimulatedMulticastDataIO -based clients are on the LAN (and using the same multicast address). When a client wants to \"multicast\" a packet, SimulatedMulticastDataIO::Write() instead sends packet separately to each group-member, via unicast UDP. To the calling code, this all looks the same as real multicast, but works better over Wi-Fi (it will generally be less efficient than actual multicast on a wired network though). See also NetworkInterfaceInfo::GetHardwareType() (and in particular, when that method returns NETWORK_INTERFACE_HARDWARE_TYPE_WIFI you might want to use this class instead of UDPSocketDataIO for your multicast traffic over that interface) Note that SimulatedMulticastDataIO uses its own proprietary discovery/enumeration protocol, so in general it is only useful for communicating with other programs that are also using a SimulatedMulticastDataIO object. In particular, it won't interact properly with third-party multicast-clients that don't know about its discovery-protocol. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/dataio (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file)","title":"muscle::SimulatedMulticastDataIO class (API)"},{"location":"slipframeddatamessageiogateway/","text":"muscle::SLIPFramedDataMessageIOGateway class (API) #include \"iogateway/SLIPFramedDataMessageIOGateway.h\" The SLIPFramedDataMessageIOGateway class transmits raw binary data across the network, but frames it using the SLIP framing protocol (RFC 1055). Useful for getting your raw binary data across in well-defined chunks (assuming the program on the other end of the connection is also using a SLIPFramedDataMessageIOGateway or some other SLIP implementation) Note that (unlike MessageIOGateway , but similar to RawDataMessageIOGateway ) this gateway won't losslessly transmit any arbitrary Message object; rather it only uses Messages as a carrier for binary data. Any other field names or data types besides PR_NAME_DATA_CHUNKS / B_RAW_TYPE will be ignored. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/iogateway (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file)","title":"SLIPFramedDataMessageIOGateway"},{"location":"slipframeddatamessageiogateway/#muscleslipframeddatamessageiogateway-class-api","text":"#include \"iogateway/SLIPFramedDataMessageIOGateway.h\" The SLIPFramedDataMessageIOGateway class transmits raw binary data across the network, but frames it using the SLIP framing protocol (RFC 1055). Useful for getting your raw binary data across in well-defined chunks (assuming the program on the other end of the connection is also using a SLIPFramedDataMessageIOGateway or some other SLIP implementation) Note that (unlike MessageIOGateway , but similar to RawDataMessageIOGateway ) this gateway won't losslessly transmit any arbitrary Message object; rather it only uses Messages as a carrier for binary data. Any other field names or data types besides PR_NAME_DATA_CHUNKS / B_RAW_TYPE will be ignored. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/iogateway (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file)","title":"muscle::SLIPFramedDataMessageIOGateway class (API)"},{"location":"socket/","text":"muscle::Socket class (API) #include \"util/Socket.h\" An RAII-friendly socket/file-descriptor wrapper. Holds/owns an int socket/file descriptor. Similar to: QTcpSocket , QUdpSocket Socket 's destructor calls close() on the file descriptor ( closesocket() on Windows) Not typically used directly; usually passed around via ConstSocketRef instead NetworkUtilityFunctions.h functions often return a ConstSocketRef object and/or take one as an argument. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/socket (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: socket/example_1_basic_usage.cpp networkutilityfunctions/example_1_tcp_client.cpp networkutilityfunctions/example_2_udp_pingpong.cpp networkutilityfunctions/example_3_udp_multicast.cpp","title":"Socket"},{"location":"socket/#musclesocket-class-api","text":"#include \"util/Socket.h\" An RAII-friendly socket/file-descriptor wrapper. Holds/owns an int socket/file descriptor. Similar to: QTcpSocket , QUdpSocket Socket 's destructor calls close() on the file descriptor ( closesocket() on Windows) Not typically used directly; usually passed around via ConstSocketRef instead NetworkUtilityFunctions.h functions often return a ConstSocketRef object and/or take one as an argument. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/socket (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: socket/example_1_basic_usage.cpp networkutilityfunctions/example_1_tcp_client.cpp networkutilityfunctions/example_2_udp_pingpong.cpp networkutilityfunctions/example_3_udp_multicast.cpp","title":"muscle::Socket class (API)"},{"location":"socketmultiplexer/","text":"muscle::SocketMultiplexer class (API) #include \"util/SocketMultiplexer.h\" A lightweight abstraction-layer around I/O multiplexing APIs ( select() / poll() / epoll() / kqueue() etc). Similar to: select() , poll() , epoll() , WaitForMultipleObjects() Default implementation calls through to select() , but an alternate back-end implementation can be specified on the compile line via e.g. -DMUSCLE_USE_POLL , etc. On each iteration of your (low-level) event loop, call RegisterSocketForReadReady() and/or RegisterSocketForWriteReady() on the SocketMultiplexer to tell it which sockets to monitor, then call WaitForEvents() to block until some I/O is ready to handle. After WaitForEvents() returns, call IsSocketReadyForRead() and/or IsSocketReadyForWrite() to find out which sockets are ready to do what category of I/O. This allows you to have a 100%-event-driven program with no wasteful polling. WaitForEvents() also takes an optional wakeup-time. If specified, WaitForEvents() will return at that time even if no I/O events have been recorded. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/socketmultiplexer (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: socketmultiplexer/example_1_tcp_echo_server.cpp socketmultiplexer/example_2_tcp_echo_server_with_timed_counter.cpp dataio/example_2_tcp_server.cpp dataio/example_6_child_process.cpp networkutilityfunctions/example_3_udp_multicast.cpp messagetransceiverthread/example_1_threaded_smart_client.cpp iogateway/example_2_message_to_tcp.cpp iogateway/example_4_text_to_tcp.cpp","title":"SocketMultiplexer"},{"location":"socketmultiplexer/#musclesocketmultiplexer-class-api","text":"#include \"util/SocketMultiplexer.h\" A lightweight abstraction-layer around I/O multiplexing APIs ( select() / poll() / epoll() / kqueue() etc). Similar to: select() , poll() , epoll() , WaitForMultipleObjects() Default implementation calls through to select() , but an alternate back-end implementation can be specified on the compile line via e.g. -DMUSCLE_USE_POLL , etc. On each iteration of your (low-level) event loop, call RegisterSocketForReadReady() and/or RegisterSocketForWriteReady() on the SocketMultiplexer to tell it which sockets to monitor, then call WaitForEvents() to block until some I/O is ready to handle. After WaitForEvents() returns, call IsSocketReadyForRead() and/or IsSocketReadyForWrite() to find out which sockets are ready to do what category of I/O. This allows you to have a 100%-event-driven program with no wasteful polling. WaitForEvents() also takes an optional wakeup-time. If specified, WaitForEvents() will return at that time even if no I/O events have been recorded. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/socketmultiplexer (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: socketmultiplexer/example_1_tcp_echo_server.cpp socketmultiplexer/example_2_tcp_echo_server_with_timed_counter.cpp dataio/example_2_tcp_server.cpp dataio/example_6_child_process.cpp networkutilityfunctions/example_3_udp_multicast.cpp messagetransceiverthread/example_1_threaded_smart_client.cpp iogateway/example_2_message_to_tcp.cpp iogateway/example_4_text_to_tcp.cpp","title":"muscle::SocketMultiplexer class (API)"},{"location":"srscommandmessages/","text":"Command Messages Page Overview This page describes the semantics of some selected Message what-codes that a StorageReflectSession will accept (via TCP) from its client. These what-codes (and their associated PR_NAME_* field-name strings) are defined in reflector/StorageReflectConstants.h See also the description in the header comments, beginning at line 139 of StorageReflectConstants.h Note that the invocation examples shown below would typically be seen in client-side code (because on the server-side, there are methods of the StorageReflectSession class that you would just call directly, which would be easier and more efficient than hand-constructing a Message object with the necessary fields and then calling MessageReceivedFromGateway() with it) Command codes This is a partial list -- the full list of command codes can be seen here . PR_COMMAND_PING - Server will echo this message, verbatim (except for the what-code) back to the sending client as a PR_RESULT_PONG reply Message This can be useful if the client wants to make sure the server is still alive and responding It's also useful as a way of getting a notification when previous operations have completed on the server (since the server will handle all commands in FIFO order) Here is an example invocation: MessageRef pingMsg = GetMessageFromPool(PR_COMMAND_PING); pingMsg()->AddString(\"put_whatever_fields_you_like\", \"in_the_ping_message\"); pingMsg()->AddString(\"they_will_come_back_to_you\", \"in_the_corresponding_pong_message\"); myMessageTransceiverThread.SendMessageToSessions(pingMsg); PR_COMMAND_SETDATA - Uploads the given Message(s) to nodes at the specified path(s) the session's local node-subtree A client would send this when it wants to publish one or more DataNodes to its local subtree of the database If a DataNode already exists at the specified path, its Message payload is updated -- otherwise a DataNode with the given Message is created there. If the parent \"directories\" of the specified path do not exist, they will be created (with default/empty Message payloads) as necessary. Note that clients can only set nodes in their session's local subtree; they aren't allowed to modify the subtrees of other sessions. The fields of this Message should have relative-paths as their names, and Messages as their values; each field represents one DataNode to post. Here is an example invocation: MessageRef setDataMsg = GetMessageFromPool(PR_COMMAND_SETDATA); setDataMsg()->AddMessage(\"nodename1\", GetMessageFromPool(1234)); setDataMsg()->AddMessage(\"nodename2\", GetMessageFromPool(1234)); setDataMsg()->AddMessage(\"blah\", GetMessageFromPool(1234)); setDataMsg()->AddMessage(\"subfolder/nodename3\", GetMessageFromPool(1234)); myMessageTransceiverThread.SendMessageToSessions(setDataMsg); PR_COMMAND_GETDATA - Requests that the server send back a PR_RESULT_DATAITEMS Message containing the contents of the specified path(s) in the node-tree If you are using live-subscriptions, this command is generally not necessary (since you'll get automatic updates anyway) Clients can use this to download the current Messages of nodes in their own session's subtree or in other sessions' subtrees If for some reason you don't want to subscribe, however, you can use this to force a one-shot retrieval of matching nodes Here is an example invocation: MessageRef getDataMsg = GetMessageFromPool(PR_COMMAND_GETDATA); getDataMsg()->AddString(PR_NAME_KEYS, \"/\\*/\\*/blah\"); // absolute path getDataMsg()->AddString(PR_NAME_KEYS, \"node*\"); // relative path getDataMsg()->AddString(PR_NAME_KEYS, \"sub*/node*\"); myMessageTransceiverThread.SendMessageToSessions(getDataMsg); PR_COMMAND_REMOVEDATA - Deletes the data nodes from the session's subtree whose paths match the patterns in the Message Use this to delete nodes in your subtree that you want gone Note that clients can only delete nodes in their own session's subtree; they aren't allowed to modify the subtrees of other sessions. Here is an example invocation: MessageRef rmvDataMsg = GetMessageFromPool(PR_COMMAND_REMOVEDATA); rmvDataMsg()->AddString(PR_NAME_KEYS, \"blah\"); rmvDataMsg()->AddString(PR_NAME_KEYS, \"node*\"); rmvDataMsg()->AddString(PR_NAME_KEYS, \"subfolder\"); // implicitly deletes children of subfolder also myMessageTransceiverThread.SendMessageToSessions(rmvDataMsg); PR_COMMAND_SETPARAMETERS - Sets parameters on the session based on the fields in the Message A session's parameters govern its behavior. In particular, parameters whose names start with the prefix \"SUBSCRIBE:\" tell the session to subscribe to whichever DataNodes have paths that match the path in the remainder of the parameters name (e.g. setting a parameter named \"SUBSCRIBE:/*/*\" would tell the session to subscribe to all DataNodes whose paths match \"/*/*\", which is a good way for the client to be informed whenever another client connects or disconnects) Here is an example invocation: MessageRef setPMsg = GetMessageFromPool(PR_COMMAND_SETPARAMETERS); setPMsg()->AddBool(\"SUBSCRIBE:/\\*/\\*\", true); // type and value of this field don't matter setPMsg()->AddBool(\"SUBSCRIBE:nodename3\", true); // relative path, equivalent to \"/*/*/nodename3\" setPMsg()->AddInt32(PR_NAME_REPLY_ENCODING, MUSCLE_MESSAGE_ENCODING_ZLIB_9); myMessageTransceiverThread.SendMessageToSessions(setPMsg); PR_COMMAND_GETPARAMETERS - Requests that the server send the session's current parameters-set back to the client, via a PR_RESULT_PARAMETERS reply Message This Message takes no parameters (i.e. there's no point adding any fields to a PR_COMMAND_GETPARAMETERS Message) Here is an example invocation: MessageRef getPMsg = GetMessageFromPool(PR_COMMAND_GETPARAMETERS); myMessageTransceiverThread.SendMessageToSessions(getPMsg); PR_COMMAND_REMOVEPARAMETERS - deletes any session parameters whose names match a pattern specified in the PR_NAME_KEYS String-field This is typically used to unsubscribe from previous subscriptions Names of parameters to unsubscribe to are places in the PR_NAME_KEYS field Note that the strings in the PR_NAME_KEYS field will be treated as wildcard-patterns (e.g. \"*\" will remove all user-settable parameters) Therefore, if you want to only match a literal path string (and that path string has wildcard chars in it), you may need to escape those wildcard chars to avoid matching other parameter names by mistake Read-only parameters (that were set by the server) cannot be deleted. Here is an example invocation: MessageRef delPMsg = GetMessageFromPool(PR_COMMAND_REMOVEPARAMETERS); delPMsg()->AddString(PR_NAME_KEYS, \"SUBSCRIBE:/\\\\\\*/\\\\\\*/node\\\\\\*\"); // cancel one specific subscription delPMsg()->AddString(PR_NAME_KEYS, \"SUBSCRIBE:\\*\"); // cancel all my subscriptions! myMessageTransceiverThread.SendMessageToSessions(delPMsg); PR_COMMAND_BATCH - Any sub-Messages in the PR_NAME_KEYS Message-field will be handled in-order, as if they had been sent separately This is particularly useful for ensuring atomicity -- i.e. if you have several Messages to send to the server and you want to guarantee that they all get executed at the same time (with no other operations allowed to happen in between) MessageRef batchMsg = GetMessageFromPool(PR_COMMAND_BATCH); batchMsg()->AddMessage(PR_NAME_KEYS, GetMessageFromPool(PR_COMMAND_SETPARAMETERS)); batchMsg()->AddMessage(PR_NAME_KEYS, GetMessageFromPool(PR_COMMAND_SETDATA)); batchMsg()->AddMessage(PR_NAME_KEYS, GetMessageFromPool(PR_COMMAND_GETPARAMETERS)); myMessageTransceiverThread.SendMessageToSessions(batchMsg); PR_COMMAND_INSERTORDEREDDATA - Insert nodes underneath a node, as an ordered list This is a specialized form of the PR_COMMAND_SETDATA command It is useful for adding a DataNode to its parent in such a way that it gets added to the parent node's indexed-nodes index. If you don't care about maintaining a well-defined ordering of the child nodes relative to each other, then you don't need this command. Here is an example invocation: MessageRef insertMsg = GetMessageFromPool(PR_COMMAND_INSERTORDEREDDATA); insertMsg()->AddString(PR_NAME_KEYS, \"blah\"); // path of an already-existing node insertMsg()->AddMessage(\"I5\", GetMessageFromPool(1234)); // add before existing node I5 insertMsg()->AddMessage(\"I8\", GetMessageFromPool(1234)); // add before existing node I8 insertMsg()->AddMessage(\"xxx\", GetMessageFromPool(1234)); // append node (assuming node \"xxx\" doesn't exist) myMessageTransceiverThread.SendMessageToSessions(insertMsg); PR_COMMAND_REORDERDATA - Moves one or more entries in an indexed-node's node-index to a different spot in its node-index This is useful only if you've previously been sending PR_COMMAND_INSERTORDEREDDATA Message to order child-nodes within their parent. If you now want to change the ordering of the child nodes relative to each other, this is more efficient then deleting a child-node and then re-uploading it (especially if the child-node's Message payload is large) Here is an example invocation: MessageRef reorderMsg = GetMessageFromPool(PR_COMMAND_REORDERDATA); reorderMsg()->AddString(\"blah/I8\", \"I5\"); // move blah's child \"I8\" to before \"I5\" reorderMsg()->AddString(\"blah/I9\", \"append\"); // move blah's child \"I9\" to the end of the index myMessageTransceiverThread.SendMessageToSessions(reorderMsg); PR_COMMAND_GETDATATREES - Returns an entire subtree of data as a single PR_RESULT_DATATREES Message The main difference between this an PR_COMMAND_GETDATA is that this form allows you to request an entire subtree to be sent back as a single Message (no matter how deep the subtree is -- PR_COMMAND_GETDATA forces you to download only a finite number of levels of subtree) Add a String in the PR_NAME_REQUEST_ID fieldname to label your request (reply Message will contain this value) You can optionally limit the depth of nodes in the reply Message by specifying a PR_NAME_MAXDEPTH int32 field Here is an example invocation: MessageRef reorderMsg = GetMessageFromPool(PR_COMMAND_GETDATATREES); reorderMsg()->AddString(PR_NAME_TREE_REQUEST_ID, \"my_request\"); reorderMsg()->AddString(PR_NAME_KEYS, \"subfolder\"); // path of subtree to start at reorderMsg()->AddInt32(PR_NAME_MAXDEPTH, 5); // no more than 5 levels deep please myMessageTransceiverThread.SendMessageToSessions(reorderMsg); Quick links to source code of relevant MUSCLE-by-example programs: reflector/example_4_smart_server.cpp reflector/example_5_smart_client.cpp test/portablereflectclient.cpp test/chatclient.cpp platform/qt/qt_example/qt_example.cpp","title":"Command Messages"},{"location":"srscommandmessages/#command-messages-page-overview","text":"This page describes the semantics of some selected Message what-codes that a StorageReflectSession will accept (via TCP) from its client. These what-codes (and their associated PR_NAME_* field-name strings) are defined in reflector/StorageReflectConstants.h See also the description in the header comments, beginning at line 139 of StorageReflectConstants.h Note that the invocation examples shown below would typically be seen in client-side code (because on the server-side, there are methods of the StorageReflectSession class that you would just call directly, which would be easier and more efficient than hand-constructing a Message object with the necessary fields and then calling MessageReceivedFromGateway() with it)","title":"Command Messages Page Overview"},{"location":"srscommandmessages/#command-codes","text":"This is a partial list -- the full list of command codes can be seen here . PR_COMMAND_PING - Server will echo this message, verbatim (except for the what-code) back to the sending client as a PR_RESULT_PONG reply Message This can be useful if the client wants to make sure the server is still alive and responding It's also useful as a way of getting a notification when previous operations have completed on the server (since the server will handle all commands in FIFO order) Here is an example invocation: MessageRef pingMsg = GetMessageFromPool(PR_COMMAND_PING); pingMsg()->AddString(\"put_whatever_fields_you_like\", \"in_the_ping_message\"); pingMsg()->AddString(\"they_will_come_back_to_you\", \"in_the_corresponding_pong_message\"); myMessageTransceiverThread.SendMessageToSessions(pingMsg); PR_COMMAND_SETDATA - Uploads the given Message(s) to nodes at the specified path(s) the session's local node-subtree A client would send this when it wants to publish one or more DataNodes to its local subtree of the database If a DataNode already exists at the specified path, its Message payload is updated -- otherwise a DataNode with the given Message is created there. If the parent \"directories\" of the specified path do not exist, they will be created (with default/empty Message payloads) as necessary. Note that clients can only set nodes in their session's local subtree; they aren't allowed to modify the subtrees of other sessions. The fields of this Message should have relative-paths as their names, and Messages as their values; each field represents one DataNode to post. Here is an example invocation: MessageRef setDataMsg = GetMessageFromPool(PR_COMMAND_SETDATA); setDataMsg()->AddMessage(\"nodename1\", GetMessageFromPool(1234)); setDataMsg()->AddMessage(\"nodename2\", GetMessageFromPool(1234)); setDataMsg()->AddMessage(\"blah\", GetMessageFromPool(1234)); setDataMsg()->AddMessage(\"subfolder/nodename3\", GetMessageFromPool(1234)); myMessageTransceiverThread.SendMessageToSessions(setDataMsg); PR_COMMAND_GETDATA - Requests that the server send back a PR_RESULT_DATAITEMS Message containing the contents of the specified path(s) in the node-tree If you are using live-subscriptions, this command is generally not necessary (since you'll get automatic updates anyway) Clients can use this to download the current Messages of nodes in their own session's subtree or in other sessions' subtrees If for some reason you don't want to subscribe, however, you can use this to force a one-shot retrieval of matching nodes Here is an example invocation: MessageRef getDataMsg = GetMessageFromPool(PR_COMMAND_GETDATA); getDataMsg()->AddString(PR_NAME_KEYS, \"/\\*/\\*/blah\"); // absolute path getDataMsg()->AddString(PR_NAME_KEYS, \"node*\"); // relative path getDataMsg()->AddString(PR_NAME_KEYS, \"sub*/node*\"); myMessageTransceiverThread.SendMessageToSessions(getDataMsg); PR_COMMAND_REMOVEDATA - Deletes the data nodes from the session's subtree whose paths match the patterns in the Message Use this to delete nodes in your subtree that you want gone Note that clients can only delete nodes in their own session's subtree; they aren't allowed to modify the subtrees of other sessions. Here is an example invocation: MessageRef rmvDataMsg = GetMessageFromPool(PR_COMMAND_REMOVEDATA); rmvDataMsg()->AddString(PR_NAME_KEYS, \"blah\"); rmvDataMsg()->AddString(PR_NAME_KEYS, \"node*\"); rmvDataMsg()->AddString(PR_NAME_KEYS, \"subfolder\"); // implicitly deletes children of subfolder also myMessageTransceiverThread.SendMessageToSessions(rmvDataMsg); PR_COMMAND_SETPARAMETERS - Sets parameters on the session based on the fields in the Message A session's parameters govern its behavior. In particular, parameters whose names start with the prefix \"SUBSCRIBE:\" tell the session to subscribe to whichever DataNodes have paths that match the path in the remainder of the parameters name (e.g. setting a parameter named \"SUBSCRIBE:/*/*\" would tell the session to subscribe to all DataNodes whose paths match \"/*/*\", which is a good way for the client to be informed whenever another client connects or disconnects) Here is an example invocation: MessageRef setPMsg = GetMessageFromPool(PR_COMMAND_SETPARAMETERS); setPMsg()->AddBool(\"SUBSCRIBE:/\\*/\\*\", true); // type and value of this field don't matter setPMsg()->AddBool(\"SUBSCRIBE:nodename3\", true); // relative path, equivalent to \"/*/*/nodename3\" setPMsg()->AddInt32(PR_NAME_REPLY_ENCODING, MUSCLE_MESSAGE_ENCODING_ZLIB_9); myMessageTransceiverThread.SendMessageToSessions(setPMsg); PR_COMMAND_GETPARAMETERS - Requests that the server send the session's current parameters-set back to the client, via a PR_RESULT_PARAMETERS reply Message This Message takes no parameters (i.e. there's no point adding any fields to a PR_COMMAND_GETPARAMETERS Message) Here is an example invocation: MessageRef getPMsg = GetMessageFromPool(PR_COMMAND_GETPARAMETERS); myMessageTransceiverThread.SendMessageToSessions(getPMsg); PR_COMMAND_REMOVEPARAMETERS - deletes any session parameters whose names match a pattern specified in the PR_NAME_KEYS String-field This is typically used to unsubscribe from previous subscriptions Names of parameters to unsubscribe to are places in the PR_NAME_KEYS field Note that the strings in the PR_NAME_KEYS field will be treated as wildcard-patterns (e.g. \"*\" will remove all user-settable parameters) Therefore, if you want to only match a literal path string (and that path string has wildcard chars in it), you may need to escape those wildcard chars to avoid matching other parameter names by mistake Read-only parameters (that were set by the server) cannot be deleted. Here is an example invocation: MessageRef delPMsg = GetMessageFromPool(PR_COMMAND_REMOVEPARAMETERS); delPMsg()->AddString(PR_NAME_KEYS, \"SUBSCRIBE:/\\\\\\*/\\\\\\*/node\\\\\\*\"); // cancel one specific subscription delPMsg()->AddString(PR_NAME_KEYS, \"SUBSCRIBE:\\*\"); // cancel all my subscriptions! myMessageTransceiverThread.SendMessageToSessions(delPMsg); PR_COMMAND_BATCH - Any sub-Messages in the PR_NAME_KEYS Message-field will be handled in-order, as if they had been sent separately This is particularly useful for ensuring atomicity -- i.e. if you have several Messages to send to the server and you want to guarantee that they all get executed at the same time (with no other operations allowed to happen in between) MessageRef batchMsg = GetMessageFromPool(PR_COMMAND_BATCH); batchMsg()->AddMessage(PR_NAME_KEYS, GetMessageFromPool(PR_COMMAND_SETPARAMETERS)); batchMsg()->AddMessage(PR_NAME_KEYS, GetMessageFromPool(PR_COMMAND_SETDATA)); batchMsg()->AddMessage(PR_NAME_KEYS, GetMessageFromPool(PR_COMMAND_GETPARAMETERS)); myMessageTransceiverThread.SendMessageToSessions(batchMsg); PR_COMMAND_INSERTORDEREDDATA - Insert nodes underneath a node, as an ordered list This is a specialized form of the PR_COMMAND_SETDATA command It is useful for adding a DataNode to its parent in such a way that it gets added to the parent node's indexed-nodes index. If you don't care about maintaining a well-defined ordering of the child nodes relative to each other, then you don't need this command. Here is an example invocation: MessageRef insertMsg = GetMessageFromPool(PR_COMMAND_INSERTORDEREDDATA); insertMsg()->AddString(PR_NAME_KEYS, \"blah\"); // path of an already-existing node insertMsg()->AddMessage(\"I5\", GetMessageFromPool(1234)); // add before existing node I5 insertMsg()->AddMessage(\"I8\", GetMessageFromPool(1234)); // add before existing node I8 insertMsg()->AddMessage(\"xxx\", GetMessageFromPool(1234)); // append node (assuming node \"xxx\" doesn't exist) myMessageTransceiverThread.SendMessageToSessions(insertMsg); PR_COMMAND_REORDERDATA - Moves one or more entries in an indexed-node's node-index to a different spot in its node-index This is useful only if you've previously been sending PR_COMMAND_INSERTORDEREDDATA Message to order child-nodes within their parent. If you now want to change the ordering of the child nodes relative to each other, this is more efficient then deleting a child-node and then re-uploading it (especially if the child-node's Message payload is large) Here is an example invocation: MessageRef reorderMsg = GetMessageFromPool(PR_COMMAND_REORDERDATA); reorderMsg()->AddString(\"blah/I8\", \"I5\"); // move blah's child \"I8\" to before \"I5\" reorderMsg()->AddString(\"blah/I9\", \"append\"); // move blah's child \"I9\" to the end of the index myMessageTransceiverThread.SendMessageToSessions(reorderMsg); PR_COMMAND_GETDATATREES - Returns an entire subtree of data as a single PR_RESULT_DATATREES Message The main difference between this an PR_COMMAND_GETDATA is that this form allows you to request an entire subtree to be sent back as a single Message (no matter how deep the subtree is -- PR_COMMAND_GETDATA forces you to download only a finite number of levels of subtree) Add a String in the PR_NAME_REQUEST_ID fieldname to label your request (reply Message will contain this value) You can optionally limit the depth of nodes in the reply Message by specifying a PR_NAME_MAXDEPTH int32 field Here is an example invocation: MessageRef reorderMsg = GetMessageFromPool(PR_COMMAND_GETDATATREES); reorderMsg()->AddString(PR_NAME_TREE_REQUEST_ID, \"my_request\"); reorderMsg()->AddString(PR_NAME_KEYS, \"subfolder\"); // path of subtree to start at reorderMsg()->AddInt32(PR_NAME_MAXDEPTH, 5); // no more than 5 levels deep please myMessageTransceiverThread.SendMessageToSessions(reorderMsg); Quick links to source code of relevant MUSCLE-by-example programs: reflector/example_4_smart_server.cpp reflector/example_5_smart_client.cpp test/portablereflectclient.cpp test/chatclient.cpp platform/qt/qt_example/qt_example.cpp","title":"Command codes"},{"location":"srsreplymessages/","text":"Result Messages Page Overview This page describes the semantics of some selected Message what-codes that a StorageReflectSession may send (via TCP) to its client. These what-codes (and their associated PR_NAME_* field-name strings) are defined in reflector/StorageReflectConstants.h See also the description in the header comments, beginning at line 139 of StorageReflectConstants.h Note that the parsing examples shown below would typically be seen in client-side code (because on the server-side, there are virtual methods of the StorageReflectSession class that you would override, which would be easier and more efficient than hand-parsing a reply- Message object that had just been created locally, just to get the data back out of it) Result codes This is a partial list -- the full list of result codes can be seen here . PR_RESULT_DATAITEMS - Sent to client in response to a PR_COMMAND_GETDATA or as a subscription update This is the primary Message-type that StorageReflectSession uses to update a client about changes to subscribed nodes in the server-side database This Message will contain either or both of two types of update: A list of node-paths of nodes that have been deleted, and a list of node-paths whose Message payloads have been created/updated. An example of how a client might parse a Message of this type follows: void ParseIncomingDataItemsMessage(const MessageRef & msg) { if (msg()->what != PR_RESULT_DATAITEMS) return; // sanity check const String * deletedNodePath; for (int i=0; (msg()->FindString(PR_NAME_REMOVED_DATAITEMS, i, &deletedNodePath) == B_NO_ERROR); i++) { printf(\"Subscribed node at path [%s] was deleted!\\n\", deletedNodePath->Cstr()); } for (MessageFieldNameIterator iter = msg()->GetFieldNameIterator(B_MESSAGE_TYPE); iter.HasData(); iter++) { const String & np = iter.GetFieldName(); MessageRef dataMsg; for (int32 i=0; msg()->FindMessage(np, i, dataMsg) == B_NO_ERROR; i++) { printf(\"Subscribed node at path [%s] was updated!\\n\", np()); printf(\"New Message payload for that path is:\\n\"); dataMsg()->PrintToStream(); } } } PR_RESULT_INDEXUPDATED - Notification that a node's ordered-children-index has been changed All of the fields of this Message will be strings The name of each field is the path of a DataNode whose ordered-children-index has changed The string-values in the field are descriptions of how it has changed A string-value equal to \"c\" (aka INDEX_OP_CLEARED ) indicates that the index has been cleared/erased A string-value starting with \"i\" (aka INDEX_OP_ENTRYINSERTED ) indicates that a node has been inserted into the index at a specified location. For example, \"i43:blah\" inserts that the child node named \"blah\" has been inserted at offset 43 of the index (note that 0 is the first valid offset). A string-value starting with \"r\" (aka INDEX_OP_ENTRYREMOVED ) indicates that a node has been inserted into the index at a specified location. For example, \"r2:blah\" means that the child node named \"blah\" has been removed from its location at offset 2 of the index (i.e. from the third position in the list) A client would typically update a local data structure according to these strings' instructions, in order to keep it in sync with the index's data structure on the server. An example of how a client might parse a Message of this type follows: // This table holds the child-node-names-in-index-order list for each // ordered-index-node that the client is subscribed to Hashtable<String, Queue<String> > indices; // nodepath -> index void ParseIncomingIndexUpdatedMessage(const MessageRef & msg) { if (msg()->what != PR_RESULT_INDEXUPDATED) return; // sanity check for (MessageFieldNameIterator iter = msg()->GetFieldNameIterator(B_STRING_TYPE); iter.HasData(); iter++) { const String & parentNodePath = iter.GetFieldName(); printf(\"Parsing index updates for DataNode at [%s]\\n\", parentNodePath()); const String * nextInstruction; for (int32 i=0; msg()->FindString(parentNodePath, i, nextInstruction) == B_NO_ERROR; i++) { const char * childName = strchr(nextInstruction->Cstr(), ':'); if (childName) childName++; // child node name starts after the colon const int indexPos = atoi(nextInstruction->Cstr()+1); switch(nextInstruction()->Cstr()[0]) { case INDEX_OP_CLEARED: // a.k.a 'c' (void) indices.Remove(parentNodePath); break; case INDEX_OP_ENTRYINSERTED: // a.k.a 'i' { Queue<String> * idx = indices.GetOrPut(parentNodePath); if (idx) (void) idx->InsertItemAt(pos, childName); } break; case INDEX_OP_ENTRYREMOVED: // a.k.a 'r' { Queue<String> * idx = indices.GetOrPut(parentNodePath); if ((idx)&&(idx->RemoveItemAt(pos) == B_NO_ERROR)&&(idx->IsEmpty())) { (void) indices.Remove(parentNodePath); } } break; } } } } Quick links to source code of relevant MUSCLE-by-example programs: reflector/example_4_smart_server.cpp reflector/example_5_smart_client.cpp test/portablereflectclient.cpp test/chatclient.cpp platform/qt/qt_example/qt_example.cpp","title":"Reply Messages"},{"location":"srsreplymessages/#result-messages-page-overview","text":"This page describes the semantics of some selected Message what-codes that a StorageReflectSession may send (via TCP) to its client. These what-codes (and their associated PR_NAME_* field-name strings) are defined in reflector/StorageReflectConstants.h See also the description in the header comments, beginning at line 139 of StorageReflectConstants.h Note that the parsing examples shown below would typically be seen in client-side code (because on the server-side, there are virtual methods of the StorageReflectSession class that you would override, which would be easier and more efficient than hand-parsing a reply- Message object that had just been created locally, just to get the data back out of it)","title":"Result Messages Page Overview"},{"location":"srsreplymessages/#result-codes","text":"This is a partial list -- the full list of result codes can be seen here . PR_RESULT_DATAITEMS - Sent to client in response to a PR_COMMAND_GETDATA or as a subscription update This is the primary Message-type that StorageReflectSession uses to update a client about changes to subscribed nodes in the server-side database This Message will contain either or both of two types of update: A list of node-paths of nodes that have been deleted, and a list of node-paths whose Message payloads have been created/updated. An example of how a client might parse a Message of this type follows: void ParseIncomingDataItemsMessage(const MessageRef & msg) { if (msg()->what != PR_RESULT_DATAITEMS) return; // sanity check const String * deletedNodePath; for (int i=0; (msg()->FindString(PR_NAME_REMOVED_DATAITEMS, i, &deletedNodePath) == B_NO_ERROR); i++) { printf(\"Subscribed node at path [%s] was deleted!\\n\", deletedNodePath->Cstr()); } for (MessageFieldNameIterator iter = msg()->GetFieldNameIterator(B_MESSAGE_TYPE); iter.HasData(); iter++) { const String & np = iter.GetFieldName(); MessageRef dataMsg; for (int32 i=0; msg()->FindMessage(np, i, dataMsg) == B_NO_ERROR; i++) { printf(\"Subscribed node at path [%s] was updated!\\n\", np()); printf(\"New Message payload for that path is:\\n\"); dataMsg()->PrintToStream(); } } } PR_RESULT_INDEXUPDATED - Notification that a node's ordered-children-index has been changed All of the fields of this Message will be strings The name of each field is the path of a DataNode whose ordered-children-index has changed The string-values in the field are descriptions of how it has changed A string-value equal to \"c\" (aka INDEX_OP_CLEARED ) indicates that the index has been cleared/erased A string-value starting with \"i\" (aka INDEX_OP_ENTRYINSERTED ) indicates that a node has been inserted into the index at a specified location. For example, \"i43:blah\" inserts that the child node named \"blah\" has been inserted at offset 43 of the index (note that 0 is the first valid offset). A string-value starting with \"r\" (aka INDEX_OP_ENTRYREMOVED ) indicates that a node has been inserted into the index at a specified location. For example, \"r2:blah\" means that the child node named \"blah\" has been removed from its location at offset 2 of the index (i.e. from the third position in the list) A client would typically update a local data structure according to these strings' instructions, in order to keep it in sync with the index's data structure on the server. An example of how a client might parse a Message of this type follows: // This table holds the child-node-names-in-index-order list for each // ordered-index-node that the client is subscribed to Hashtable<String, Queue<String> > indices; // nodepath -> index void ParseIncomingIndexUpdatedMessage(const MessageRef & msg) { if (msg()->what != PR_RESULT_INDEXUPDATED) return; // sanity check for (MessageFieldNameIterator iter = msg()->GetFieldNameIterator(B_STRING_TYPE); iter.HasData(); iter++) { const String & parentNodePath = iter.GetFieldName(); printf(\"Parsing index updates for DataNode at [%s]\\n\", parentNodePath()); const String * nextInstruction; for (int32 i=0; msg()->FindString(parentNodePath, i, nextInstruction) == B_NO_ERROR; i++) { const char * childName = strchr(nextInstruction->Cstr(), ':'); if (childName) childName++; // child node name starts after the colon const int indexPos = atoi(nextInstruction->Cstr()+1); switch(nextInstruction()->Cstr()[0]) { case INDEX_OP_CLEARED: // a.k.a 'c' (void) indices.Remove(parentNodePath); break; case INDEX_OP_ENTRYINSERTED: // a.k.a 'i' { Queue<String> * idx = indices.GetOrPut(parentNodePath); if (idx) (void) idx->InsertItemAt(pos, childName); } break; case INDEX_OP_ENTRYREMOVED: // a.k.a 'r' { Queue<String> * idx = indices.GetOrPut(parentNodePath); if ((idx)&&(idx->RemoveItemAt(pos) == B_NO_ERROR)&&(idx->IsEmpty())) { (void) indices.Remove(parentNodePath); } } break; } } } } Quick links to source code of relevant MUSCLE-by-example programs: reflector/example_4_smart_server.cpp reflector/example_5_smart_client.cpp test/portablereflectclient.cpp test/chatclient.cpp platform/qt/qt_example/qt_example.cpp","title":"Result codes"},{"location":"sslsocketdataio/","text":"muscle::SSLSocketDataIO class (API) #include \"dataio/SSLSocketDataIO.h\" SSLSocketDataIO works similarly to a TCPSocketDataIO , except it runs encrypted over SSL instead of directly over TCP. In most cases to use SSLSocketDataIO correctly you'll also need to wrap your session's gateway in a SSLSocketAdapterGateway object -- otherwise OpenSSL's internal state machine will get confused and not work correctly (OpenSSL is a bit of a mess architecturally :( ) Depending on what you're doing, you'll probably want to call SetPublicKeyCertificate() (if you're a client), or SetPrivateKey() (if you're a server) to handle authentication issues. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/dataio (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file)","title":"SSLSocketDataIO"},{"location":"sslsocketdataio/#musclesslsocketdataio-class-api","text":"#include \"dataio/SSLSocketDataIO.h\" SSLSocketDataIO works similarly to a TCPSocketDataIO , except it runs encrypted over SSL instead of directly over TCP. In most cases to use SSLSocketDataIO correctly you'll also need to wrap your session's gateway in a SSLSocketAdapterGateway object -- otherwise OpenSSL's internal state machine will get confused and not work correctly (OpenSSL is a bit of a mess architecturally :( ) Depending on what you're doing, you'll probably want to call SetPublicKeyCertificate() (if you're a client), or SetPrivateKey() (if you're a server) to handle authentication issues. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/dataio (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file)","title":"muscle::SSLSocketDataIO class (API)"},{"location":"stdindataio/","text":"muscle::StdinDataIO class (API) #include \"dataio/StdinDataIO.h\" StdinDataIO reads data from the process's built-in stdin stream. Under Mac/Linux, StdinDataIO is implemented as a simple pass-through to a FileDescriptorDataIO member-object for STDIN_FILENO . Under Windows, stdin can't be select() 'd on, so StdinDataIO is implemented using lots of special magic, an internal thread, and a socket-pair. The result is that StdinDataIO under Windows behaves that same as StdinDataIO under other OS's, despite Windows' limitations. By default, any data passed to StdinDataIO::Write() is simply discarded, since writing to stdin doesn't really make sense. However, if you pass true to the StdinDataIO constructor's second argument, then any data passed to StdinDataIO::Write() will be printed to stdout instead. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/dataio (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: dataio/example_1_basic_usage.cpp dataio/example_2_tcp_server.cpp dataio/example_6_child_process.cpp","title":"StdinDataIO"},{"location":"stdindataio/#musclestdindataio-class-api","text":"#include \"dataio/StdinDataIO.h\" StdinDataIO reads data from the process's built-in stdin stream. Under Mac/Linux, StdinDataIO is implemented as a simple pass-through to a FileDescriptorDataIO member-object for STDIN_FILENO . Under Windows, stdin can't be select() 'd on, so StdinDataIO is implemented using lots of special magic, an internal thread, and a socket-pair. The result is that StdinDataIO under Windows behaves that same as StdinDataIO under other OS's, despite Windows' limitations. By default, any data passed to StdinDataIO::Write() is simply discarded, since writing to stdin doesn't really make sense. However, if you pass true to the StdinDataIO constructor's second argument, then any data passed to StdinDataIO::Write() will be printed to stdout instead. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/dataio (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: dataio/example_1_basic_usage.cpp dataio/example_2_tcp_server.cpp dataio/example_6_child_process.cpp","title":"muscle::StdinDataIO class (API)"},{"location":"storagereflectsession/","text":"muscle::StorageReflectSession class (API) #include \"reflector/StorageReflectSession.h\" StorageReflectSession implements the full MUSCLE server-side database and wildcard-based Message -forwarding functionality. Clients of a ReflectServer using StorageReflectSession objects can post Messages into to their partition of the server-side DataNode tree. Clients can also set up live-subscriptions so that they get notified whenever node of interest are created, deleted, or updated. Clients can include wildcard-patterns in a PR_NAME_KEYS String field of their outgoing Messages to indicate which other connected client(s) the server should forward the Messages to. See The MUSCLE Beginner's Guide for more details. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/reflector (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: reflector/example_4_smart_server.cpp reflector/example_5_smart_client.cpp reflector/example_6_smart_server_with_pulsenode.cpp reflector/example_7_smart_server_with_udp_pingpong.cpp","title":"StorageReflectSession"},{"location":"storagereflectsession/#musclestoragereflectsession-class-api","text":"#include \"reflector/StorageReflectSession.h\" StorageReflectSession implements the full MUSCLE server-side database and wildcard-based Message -forwarding functionality. Clients of a ReflectServer using StorageReflectSession objects can post Messages into to their partition of the server-side DataNode tree. Clients can also set up live-subscriptions so that they get notified whenever node of interest are created, deleted, or updated. Clients can include wildcard-patterns in a PR_NAME_KEYS String field of their outgoing Messages to indicate which other connected client(s) the server should forward the Messages to. See The MUSCLE Beginner's Guide for more details. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/reflector (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: reflector/example_4_smart_server.cpp reflector/example_5_smart_client.cpp reflector/example_6_smart_server_with_pulsenode.cpp reflector/example_7_smart_server_with_udp_pingpong.cpp","title":"muscle::StorageReflectSession class (API)"},{"location":"string/","text":"muscle::String class (API) #include \"util/String.h\" Holds a resizable array of chars that contains a 0-terminated C-string (ASCII or UTF-8). Similar to: QString , std::string , java.util.String Supports string lengths up to (2^32)-1 bytes Short-string optimization: Strings less than 8 bytes long require no heap allocations Idiom: () operator is a shorthand for calling Cstr() method to get a (const char *) : const String s = \"foobar\"; const char * cptr = s(); // s() is shorthand for s.Cstr() printf(\"s contains [%s]\\n\", cptr); Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/string (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: string/example_1_basic_usage.cpp string/example_2_substrings.cpp string/example_3_interactive.cpp string/example_4_interpolation.cpp","title":"String"},{"location":"string/#musclestring-class-api","text":"#include \"util/String.h\" Holds a resizable array of chars that contains a 0-terminated C-string (ASCII or UTF-8). Similar to: QString , std::string , java.util.String Supports string lengths up to (2^32)-1 bytes Short-string optimization: Strings less than 8 bytes long require no heap allocations Idiom: () operator is a shorthand for calling Cstr() method to get a (const char *) : const String s = \"foobar\"; const char * cptr = s(); // s() is shorthand for s.Cstr() printf(\"s contains [%s]\\n\", cptr); Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/string (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: string/example_1_basic_usage.cpp string/example_2_substrings.cpp string/example_3_interactive.cpp string/example_4_interpolation.cpp","title":"muscle::String class (API)"},{"location":"stringmatcher/","text":"muscle::StringMatcher class (API) #include \"regex/StringMatcher.h\" Holds a pattern-string (ASCII or UTF-8) that represents a bash-shell-style wildcard/globbing-pattern, and uses it to do pattern-matching. StringMatcher::Match(const char *) returns true iff the pattern-string matches the passed-in string. Similar to: QRegularExpression , std::regex_match For example, glob-pattern str* will match \"string\" and \"strap\" but not \"ring\" or \"trap\". Supported \"traditional\" wildcard-characters include * , ? , [ , ] , \\ , , , ( , ) Syntax extension: a glob-pattern starting with ~ will match only strings that don't match the rest of the pattern (e.g. ~j* will match all strings that don't start with \"j\") Syntax extension: a glob-pattern like <3-5,10-12,20-> will match strings that represent integers in the specified range(s) (e.g. \"3\", \"4\", \"5\", \"10\", \"11\", and \"12\", plus \"20\" and higher) StringMatcher can also be used to match against standard regex-patterns, if the simplified bash-shell-style globbing-syntax isn't sufficient. (pass in false as the second constructor-argument to enable full-regex mode) Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/stringmatcher (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: stringmatcher/example_1_glob_matching.cpp stringmatcher/example_2_regex_matching.cpp","title":"StringMatcher"},{"location":"stringmatcher/#musclestringmatcher-class-api","text":"#include \"regex/StringMatcher.h\" Holds a pattern-string (ASCII or UTF-8) that represents a bash-shell-style wildcard/globbing-pattern, and uses it to do pattern-matching. StringMatcher::Match(const char *) returns true iff the pattern-string matches the passed-in string. Similar to: QRegularExpression , std::regex_match For example, glob-pattern str* will match \"string\" and \"strap\" but not \"ring\" or \"trap\". Supported \"traditional\" wildcard-characters include * , ? , [ , ] , \\ , , , ( , ) Syntax extension: a glob-pattern starting with ~ will match only strings that don't match the rest of the pattern (e.g. ~j* will match all strings that don't start with \"j\") Syntax extension: a glob-pattern like <3-5,10-12,20-> will match strings that represent integers in the specified range(s) (e.g. \"3\", \"4\", \"5\", \"10\", \"11\", and \"12\", plus \"20\" and higher) StringMatcher can also be used to match against standard regex-patterns, if the simplified bash-shell-style globbing-syntax isn't sufficient. (pass in false as the second constructor-argument to enable full-regex mode) Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/stringmatcher (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: stringmatcher/example_1_glob_matching.cpp stringmatcher/example_2_regex_matching.cpp","title":"muscle::StringMatcher class (API)"},{"location":"stringtokenizer/","text":"muscle::StringTokenizer class (API) #include \"util/StringTokenizer.h\" MUSCLE's class for iterating over substrings in a string. Given a C-string, parses out the contained words or clauses in order Similar to: strtok() , java.util.StringTokenizer , boost::tokenizer More than one token-separator-char can be specified (e.g. spaces AND commas) By default, separator-chars are \"soft\": multiple adjacent soft-separator-chars will be treated as if they were a single separator-char. (Useful for whitespace) If you specify a separator-char more than once in the constructor-argument, it will become a \"hard\" separator; multiple adjacent hard-separator-chars will be treated as separating empty strings. e.g. this code: const char * parseMe = \"one,two, three ,,four five\"; StringTokenizer tok(parseMe, \",, \"); // comma is deliberately specified twice to make it a \"hard separator char\" const char * nextTok; while((nextTok = tok()) != NULL) { printf(\"[%s]\\n\", nextTok); } will print: [one] [two] [three] [] [four] [five] Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/stringtokenizer (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: stringtokenizer/example_1_basic_usage.cpp","title":"StringTokenizer"},{"location":"stringtokenizer/#musclestringtokenizer-class-api","text":"#include \"util/StringTokenizer.h\" MUSCLE's class for iterating over substrings in a string. Given a C-string, parses out the contained words or clauses in order Similar to: strtok() , java.util.StringTokenizer , boost::tokenizer More than one token-separator-char can be specified (e.g. spaces AND commas) By default, separator-chars are \"soft\": multiple adjacent soft-separator-chars will be treated as if they were a single separator-char. (Useful for whitespace) If you specify a separator-char more than once in the constructor-argument, it will become a \"hard\" separator; multiple adjacent hard-separator-chars will be treated as separating empty strings. e.g. this code: const char * parseMe = \"one,two, three ,,four five\"; StringTokenizer tok(parseMe, \",, \"); // comma is deliberately specified twice to make it a \"hard separator char\" const char * nextTok; while((nextTok = tok()) != NULL) { printf(\"[%s]\\n\", nextTok); } will print: [one] [two] [three] [] [four] [five] Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/stringtokenizer (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: stringtokenizer/example_1_basic_usage.cpp","title":"muscle::StringTokenizer class (API)"},{"location":"systeminfo/","text":"muscle::SystemInfo functions (API) #include \"system/SystemInfo.h\" Functions that return gestalt information about the environment the program is running in. GetOSName() returns a string representing the OS the executable was compiled on. GetSystemPath() returns the filesystem-paths to various resources (executable path, desktop path, etc) GetNumberOfProcessors() returns the number of CPU cores on the computer we are running on etc Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/systeminfo (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: systeminfo/example_1_basic_usage.cpp","title":"SystemInfo"},{"location":"systeminfo/#musclesysteminfo-functions-api","text":"#include \"system/SystemInfo.h\" Functions that return gestalt information about the environment the program is running in. GetOSName() returns a string representing the OS the executable was compiled on. GetSystemPath() returns the filesystem-paths to various resources (executable path, desktop path, etc) GetNumberOfProcessors() returns the number of CPU cores on the computer we are running on etc Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/systeminfo (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: systeminfo/example_1_basic_usage.cpp","title":"muscle::SystemInfo functions (API)"},{"location":"tarfilewriter/","text":"muscle::TarFileWriter class (API) #include \"zlib/TarFileWriter.h\" A TarFileWriter can be used to create a .tar archive file It can also be used to append more files to an existing .tar file Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/tarfilewriter (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: tarfilewriter/example_1_basic_usage.cpp","title":"TarFileWriter"},{"location":"tarfilewriter/#muscletarfilewriter-class-api","text":"#include \"zlib/TarFileWriter.h\" A TarFileWriter can be used to create a .tar archive file It can also be used to append more files to an existing .tar file Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/tarfilewriter (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: tarfilewriter/example_1_basic_usage.cpp","title":"muscle::TarFileWriter class (API)"},{"location":"tcpsocketdataio/","text":"muscle::TCPSocketDataIO class (API) #include \"dataio/TCPSocketDataIO.h\" TCPSocketDataIO handles transmitting and receiving data over a TCP connection. The default implementation of the CreateDataIO(const ConstSocketRef &) method in the session classes ( AbstractReflectSession and its subclasses) creates a TCPSocketDataIO object. TCPSocketDataIO::FlushOutput() is implemented to force pending outgoing data across the TCP socket ASAP. It is called by the gateway objects when they are done sending data for the time being, to avoid any Nagle-induced delay. TCPSocketDataIO::GetOutputStallLimit() returns 180,000,000 microseconds (aka 3 minutes) by default, but can be set to another timeout value if you prefer. That will control how much time elapses before a \"stalled\" session (whose client has stopped reading data, but hasn't disconnected) is abandoned. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/dataio (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: dataio/example_2_tcp_server.cpp","title":"TCPSocketDataIO"},{"location":"tcpsocketdataio/#muscletcpsocketdataio-class-api","text":"#include \"dataio/TCPSocketDataIO.h\" TCPSocketDataIO handles transmitting and receiving data over a TCP connection. The default implementation of the CreateDataIO(const ConstSocketRef &) method in the session classes ( AbstractReflectSession and its subclasses) creates a TCPSocketDataIO object. TCPSocketDataIO::FlushOutput() is implemented to force pending outgoing data across the TCP socket ASAP. It is called by the gateway objects when they are done sending data for the time being, to avoid any Nagle-induced delay. TCPSocketDataIO::GetOutputStallLimit() returns 180,000,000 microseconds (aka 3 minutes) by default, but can be set to another timeout value if you prefer. That will control how much time elapses before a \"stalled\" session (whose client has stopped reading data, but hasn't disconnected) is abandoned. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/dataio (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: dataio/example_2_tcp_server.cpp","title":"muscle::TCPSocketDataIO class (API)"},{"location":"thread/","text":"muscle::Thread class (API) #include \"system/Thread.h\" MUSCLE's Thread class A Thread object holds a captive internal thread, plus two low-latency/zero-copy FIFO MessageRef queues (one for the main/owning thread to send command Message objects to the internal thread, and a second one for the internal thread to send reply Message objects back to the main/owning thread) Similar to: std::thread , pthread_create() , QThread , _beginthreadex When compiled with C++11, Thread is implemented via std::thread . Otherwise, it will be implemented using an appropriate threading API (i.e. pthreads or an OS-specific API). Call StartInternalThread() to start the internal thread running Call ShutdownInternalThread() to tell the internal thread to go away ( ShutdownInternalThread() will, by default, wait until the thread exits before returning) Call WaitForInternalThreadToExit() to block until the internal thread has exited (similar to pthread_join ) (only necessary if you passed false as an argument to ShutdownInternalThread() , of course) Call SendMessageToInternalThread() to (asynchronously) send a command Message to the internal thread, i.e. to tell it to wake up and to do something Call GetNextReplyFromInternalThread() to receive a reply Message back from the internal thread (the call's second argument can be used to block waiting for the Message , if desired) The ConstSocketRef returned by GetOwnerWakeupSocket() can be used by the main thread (in conjunction with select() / SignalMultiplexer (etc)) as a way to wake up when the next reply Message is available from the internal thread. The default implementation of Thread::InternalThreadEntry() runs a while-loop around calls to WaitForNextMessageFromOwner() and MessageReceivedFromOwner() , so if you just need the internal thread to react to Message commands you send it, you need only override the Thread::MessageReceivedFromOwner() callback method. If you need to write your own custom event-loop for the internal thread, you are free to override Thread::InternalThreadEntry() to do whatever you need the internal thread to do. Note that ShutdownInternalThread() will signal the internal thread that it is time to exit by calling SendMessageToInternalThread(MessageRef()) -- that is, by sending a NULL MessageRef to the internal thread. Thread priority can be set via SetThreadPriority() Thread stack size can be set via SetSuggestedStackSize() (must be done before calling StartInternalThread() ) Another example can be seen in this demonstration of how to add multithreading to a MUSCLE server Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/thread (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: thread/example_1_basic_usage.cpp thread/example_2_dumb_server_with_thread.cpp","title":"Thread"},{"location":"thread/#musclethread-class-api","text":"#include \"system/Thread.h\" MUSCLE's Thread class A Thread object holds a captive internal thread, plus two low-latency/zero-copy FIFO MessageRef queues (one for the main/owning thread to send command Message objects to the internal thread, and a second one for the internal thread to send reply Message objects back to the main/owning thread) Similar to: std::thread , pthread_create() , QThread , _beginthreadex When compiled with C++11, Thread is implemented via std::thread . Otherwise, it will be implemented using an appropriate threading API (i.e. pthreads or an OS-specific API). Call StartInternalThread() to start the internal thread running Call ShutdownInternalThread() to tell the internal thread to go away ( ShutdownInternalThread() will, by default, wait until the thread exits before returning) Call WaitForInternalThreadToExit() to block until the internal thread has exited (similar to pthread_join ) (only necessary if you passed false as an argument to ShutdownInternalThread() , of course) Call SendMessageToInternalThread() to (asynchronously) send a command Message to the internal thread, i.e. to tell it to wake up and to do something Call GetNextReplyFromInternalThread() to receive a reply Message back from the internal thread (the call's second argument can be used to block waiting for the Message , if desired) The ConstSocketRef returned by GetOwnerWakeupSocket() can be used by the main thread (in conjunction with select() / SignalMultiplexer (etc)) as a way to wake up when the next reply Message is available from the internal thread. The default implementation of Thread::InternalThreadEntry() runs a while-loop around calls to WaitForNextMessageFromOwner() and MessageReceivedFromOwner() , so if you just need the internal thread to react to Message commands you send it, you need only override the Thread::MessageReceivedFromOwner() callback method. If you need to write your own custom event-loop for the internal thread, you are free to override Thread::InternalThreadEntry() to do whatever you need the internal thread to do. Note that ShutdownInternalThread() will signal the internal thread that it is time to exit by calling SendMessageToInternalThread(MessageRef()) -- that is, by sending a NULL MessageRef to the internal thread. Thread priority can be set via SetThreadPriority() Thread stack size can be set via SetSuggestedStackSize() (must be done before calling StartInternalThread() ) Another example can be seen in this demonstration of how to add multithreading to a MUSCLE server Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/thread (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: thread/example_1_basic_usage.cpp thread/example_2_dumb_server_with_thread.cpp","title":"muscle::Thread class (API)"},{"location":"threadlocalstorage/","text":"muscle::ThreadLocalStorage class (API) #include \"system/ThreadLocalStorage.h\" ThreadLocalStorage is a templated class that lets a (typically) global/static variable keep a different state for each thread that accesses it. Declare the ThreadLocalStorage<T> object e.g. as a static variable Each thread can call GetOrCreateThreadLocalObject() on the ThreadLocalStorage object to get a pointer to the underlying per-thread variable, and then use it the way they want to (i.e. without worrying about other threads seeing or modifying their instance of that value) Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/threadlocalstorage (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: threadlocalstorage/example_1_basic_usage.cpp","title":"ThreadLocalStorage"},{"location":"threadlocalstorage/#musclethreadlocalstorage-class-api","text":"#include \"system/ThreadLocalStorage.h\" ThreadLocalStorage is a templated class that lets a (typically) global/static variable keep a different state for each thread that accesses it. Declare the ThreadLocalStorage<T> object e.g. as a static variable Each thread can call GetOrCreateThreadLocalObject() on the ThreadLocalStorage object to get a pointer to the underlying per-thread variable, and then use it the way they want to (i.e. without worrying about other threads seeing or modifying their instance of that value) Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/threadlocalstorage (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: threadlocalstorage/example_1_basic_usage.cpp","title":"muscle::ThreadLocalStorage class (API)"},{"location":"timeutilityfunctions/","text":"Time Utility Functions (API) #include \"util/TimeUtilityFunctions.h\" TimeUtilityFunctions is a collection of functions for dealing with time (expressed as uint64s , representing microseconds) GetRunTime64() returns the current time according to a monotonic clock (unrelated to calendar time) -- useful for program activity scheduling GetCurrentTime64() returns the current time according to the calendar clock -- useful for human-centric time/date calculations Snooze64() sleeps for the specified number of microseconds GetHumanReadableTimeString() returns a human-readable date/time string representing a given uint64 calendar-clock-value ParseHumanReadableTimeString() returns the uint64 value associated with a GetHumanReadableTimeString() -style human-readable date/time string. GetHumanReadableTimeValues() populates a HumanReadableTimeValues object with year/month/date/hours/minutes/seconds values representing a given date/time. GetHumanReadableTimeIntervalString() returns a human-readable string representing a specified duration of time. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/timeutilityfunctions (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: timeutilityfunctions/example_1_monotonic_clock.cpp timeutilityfunctions/example_2_calendar_time.cpp timeutilityfunctions/example_3_idioms.cpp","title":"TimeUtilityFunctions"},{"location":"timeutilityfunctions/#time-utility-functions-api","text":"#include \"util/TimeUtilityFunctions.h\" TimeUtilityFunctions is a collection of functions for dealing with time (expressed as uint64s , representing microseconds) GetRunTime64() returns the current time according to a monotonic clock (unrelated to calendar time) -- useful for program activity scheduling GetCurrentTime64() returns the current time according to the calendar clock -- useful for human-centric time/date calculations Snooze64() sleeps for the specified number of microseconds GetHumanReadableTimeString() returns a human-readable date/time string representing a given uint64 calendar-clock-value ParseHumanReadableTimeString() returns the uint64 value associated with a GetHumanReadableTimeString() -style human-readable date/time string. GetHumanReadableTimeValues() populates a HumanReadableTimeValues object with year/month/date/hours/minutes/seconds values representing a given date/time. GetHumanReadableTimeIntervalString() returns a human-readable string representing a specified duration of time. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/timeutilityfunctions (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: timeutilityfunctions/example_1_monotonic_clock.cpp timeutilityfunctions/example_2_calendar_time.cpp timeutilityfunctions/example_3_idioms.cpp","title":"Time Utility Functions (API)"},{"location":"udpsocketdataio/","text":"muscle::UDPSocketDataIO class (API) #include \"dataio/UDPSocketDataIO.h\" UDPSocketDataIO handles transmitting and receiving data via UDP packets. UDPSocketDataIO is a subclass of PacketDataIO , so it has the additional packet-I/O related functionality described in that class. SetPacketSendDestination(const IPAddressAndPort &) can be called to specify where PacketDataIO::Write() should send its outgoing UDP packets should be sent to SetPacketSendDestinations(const Queue<IPAddressAndPort> &) can be called to specify that PacketDataIO::Write() should send each outgoing UDP packet to multiple destinations. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/dataio (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: dataio/example_5_packet_dataio.cpp reflector/example_7_smart_server_with_udp_pingpong.cpp","title":"UDPSocketDataIO"},{"location":"udpsocketdataio/#muscleudpsocketdataio-class-api","text":"#include \"dataio/UDPSocketDataIO.h\" UDPSocketDataIO handles transmitting and receiving data via UDP packets. UDPSocketDataIO is a subclass of PacketDataIO , so it has the additional packet-I/O related functionality described in that class. SetPacketSendDestination(const IPAddressAndPort &) can be called to specify where PacketDataIO::Write() should send its outgoing UDP packets should be sent to SetPacketSendDestinations(const Queue<IPAddressAndPort> &) can be called to specify that PacketDataIO::Write() should send each outgoing UDP packet to multiple destinations. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/dataio (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: dataio/example_5_packet_dataio.cpp reflector/example_7_smart_server_with_udp_pingpong.cpp","title":"muscle::UDPSocketDataIO class (API)"},{"location":"void/","text":"muscle::Void class (API) #include \"util/Hashtable.h\" A Void is a minimal dummy-object with no data or methods. Its primary use is to serve as a \"placeholder\" value-type in a Hashtable that needs only to keep keys and not values. Every Void object is equal to every other Void object.","title":"Void"},{"location":"void/#musclevoid-class-api","text":"#include \"util/Hashtable.h\" A Void is a minimal dummy-object with no data or methods. Its primary use is to serve as a \"placeholder\" value-type in a Hashtable that needs only to keep keys and not values. Every Void object is equal to every other Void object.","title":"muscle::Void class (API)"},{"location":"waitcondition/","text":"muscle::WaitCondition class (API) #include \"system/WaitCondition.h\" MUSCLE's WaitCondition class A WaitCondition is a simple, lightweight thread-notification mechanism. A thread can call Wait() on the WaitCondition , and Wait() won't return until another thread calls Notify() on it (or optionally until a timeout-time is reached). Any calls to Notify() that happen at a time when no thread is waiting on the WaitCondition will be cached, and will cause the next call to Wait() to return immediately. Similar to: std::condition_variable , QWaitCondition , SleepConditionVariableCS When compiled with C++11, WaitCondition is implemented via std::condition_variable . Otherwise, it will be implemented using an appropriate threading API (i.e. pthreads or an OS-specific API). Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/waitcondition (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: waitcondition/example_1_basic_usage.cpp waitcondition/example_2_ping_pong.cpp","title":"WaitCondition"},{"location":"waitcondition/#musclewaitcondition-class-api","text":"#include \"system/WaitCondition.h\" MUSCLE's WaitCondition class A WaitCondition is a simple, lightweight thread-notification mechanism. A thread can call Wait() on the WaitCondition , and Wait() won't return until another thread calls Notify() on it (or optionally until a timeout-time is reached). Any calls to Notify() that happen at a time when no thread is waiting on the WaitCondition will be cached, and will cause the next call to Wait() to return immediately. Similar to: std::condition_variable , QWaitCondition , SleepConditionVariableCS When compiled with C++11, WaitCondition is implemented via std::condition_variable . Otherwise, it will be implemented using an appropriate threading API (i.e. pthreads or an OS-specific API). Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/waitcondition (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: waitcondition/example_1_basic_usage.cpp waitcondition/example_2_ping_pong.cpp","title":"muscle::WaitCondition class (API)"},{"location":"win32filehandledataio/","text":"muscle::Win32FileHandleDataIO class (API) #include \"winsupport/Win32FileHandleDataIO.h\" Win32FileHandleDataIO is used to read/write data from a Windows HANDLE (an opaque type, as returned by CreateFile() , etc). This class can only be used under Windows Typically used as a way to interface OS-neutral MUSCLE code to a Win32-specific I/O API. The Win32FileHandleDataIO object will assume ownership of the HANDLE handle you pass in to it, so don't need to (and shouldn't) call CloseHandle() on it yourself.","title":"Win32FileHandleDataIO"},{"location":"win32filehandledataio/#musclewin32filehandledataio-class-api","text":"#include \"winsupport/Win32FileHandleDataIO.h\" Win32FileHandleDataIO is used to read/write data from a Windows HANDLE (an opaque type, as returned by CreateFile() , etc). This class can only be used under Windows Typically used as a way to interface OS-neutral MUSCLE code to a Win32-specific I/O API. The Win32FileHandleDataIO object will assume ownership of the HANDLE handle you pass in to it, so don't need to (and shouldn't) call CloseHandle() on it yourself.","title":"muscle::Win32FileHandleDataIO class (API)"},{"location":"zipfileutilityfunctions/","text":"muscle::ZipFileUtilityFunctions class (API) #include \"zlib/ZipFileUtilityFunctions.h\" The functions in ZipFileUtilityFunctions allow you to easily read and write small .zip files. ReadZipFile() reads in a .zip file, inflates its contents, and returns the result as a Message object. In the returned Message , sub-directories are represented as sub-Messages, and files are represented as B_RAW_DATA_TYPE fields with the filename as the field-name. WriteZipFile() takes a Message object (in the form returned by ReadZipFile() and writes out the corresponding .zip file Note that since the entire .zip file is read into memory at once (and inflated!), reading huge .zip files via this API will require a lot of RAM. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/zipfileutilityfunctions (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: zipfileutilityfunctions/example_1_read_zip.cpp zipfileutilityfunctions/example_2_write_zip.cpp","title":"ZipFileUtilityFunctions"},{"location":"zipfileutilityfunctions/#musclezipfileutilityfunctions-class-api","text":"#include \"zlib/ZipFileUtilityFunctions.h\" The functions in ZipFileUtilityFunctions allow you to easily read and write small .zip files. ReadZipFile() reads in a .zip file, inflates its contents, and returns the result as a Message object. In the returned Message , sub-directories are represented as sub-Messages, and files are represented as B_RAW_DATA_TYPE fields with the filename as the field-name. WriteZipFile() takes a Message object (in the form returned by ReadZipFile() and writes out the corresponding .zip file Note that since the entire .zip file is read into memory at once (and inflated!), reading huge .zip files via this API will require a lot of RAM. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/zipfileutilityfunctions (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: zipfileutilityfunctions/example_1_read_zip.cpp zipfileutilityfunctions/example_2_write_zip.cpp","title":"muscle::ZipFileUtilityFunctions class (API)"},{"location":"zlibcodec/","text":"muscle::ZLibCodec class (API) #include \"zlib/ZLibCodec.h\" ZlibCodec is a wrapper API around the ZLib compression library's useful (but difficult-to-use-correctly) inflate() and deflate() functions. Deflate() takes a pointer to a buffer of raw data, and returns a ByteBufferRef containing equivalent (but hopefully smaller) deflated data. Inflate() takes a pointer to a buffer of deflated data (as previously generated by Deflate() and returns a ByteBufferRef containing the original raw data. ReadAndDeflateAndWrite() can be used to deflate large raw-data files without having to read the entire raw-data file into memory first. ReadAndInflateAndWrite() can be used to inflate large deflated files without having to read the entire deflated-data file into memory first. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/zlibcodec (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: zlibcodec/example_1_basic_usage.cpp zlibcodec/example_2_dependent_series.cpp","title":"ZLibCodec"},{"location":"zlibcodec/#musclezlibcodec-class-api","text":"#include \"zlib/ZLibCodec.h\" ZlibCodec is a wrapper API around the ZLib compression library's useful (but difficult-to-use-correctly) inflate() and deflate() functions. Deflate() takes a pointer to a buffer of raw data, and returns a ByteBufferRef containing equivalent (but hopefully smaller) deflated data. Inflate() takes a pointer to a buffer of deflated data (as previously generated by Deflate() and returns a ByteBufferRef containing the original raw data. ReadAndDeflateAndWrite() can be used to deflate large raw-data files without having to read the entire raw-data file into memory first. ReadAndInflateAndWrite() can be used to inflate large deflated files without having to read the entire deflated-data file into memory first. Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/zlibcodec (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: zlibcodec/example_1_basic_usage.cpp zlibcodec/example_2_dependent_series.cpp","title":"muscle::ZLibCodec class (API)"},{"location":"zlibutilityfunctions/","text":"muscle::ZLibUtilityFunctions class (API) #include \"zlib/ZLibUtilityFunctions.h\" The functions in ZLibUtilityFunctions are convenience functions for quickly deflating or inflating data. DeflateByteBuffer() takes a ByteBufferRef of raw data and returns a corresponding ByteBufferRef of deflated data InflateByteBuffer() takes a ByteBufferRef of deflated data (previously produced by DeflateByteBuffer() ) and returns a corresponding ByteBufferRef of re-inflated data DeflateMessage() takes a MessageRef and returns a corresponding MessageRef containing only a single field of flattened data (but with the same what -code as the original Message ) -- or if the MessageRef that was passed in was already deflated, it just returns the passed-in MessageRef verbatim. InflateMessage() takes a MessageRef that was previously returned by DeflateMessage() and returns a corresponding re-inflated MessageRef containing all of the original fields again. (or if the MessageRef that was passed in wasn't a deflated Message, it just returns the passed-in MessageRef verbatim) ReadAndDeflateAndWrite() reads raw data from one DataIO , deflates it, and writes the deflated data out to another DataIO , without ever loading all of the data into RAM at once. (Useful for deflating large files) ReadAndInflateAndWrite() reads deflated data from one DataIO , inflates it, and writes the inflated data out to another DataIO , without ever loading all of the data into RAM at once. (Useful for inflating large files) Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/zlibutilityfunctions (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: zlibutilityfunctions/example_1_byte_buffers.cpp zlibutilityfunctions/example_2_messages.cpp","title":"ZLibUtilityFunctions"},{"location":"zlibutilityfunctions/#musclezlibutilityfunctions-class-api","text":"#include \"zlib/ZLibUtilityFunctions.h\" The functions in ZLibUtilityFunctions are convenience functions for quickly deflating or inflating data. DeflateByteBuffer() takes a ByteBufferRef of raw data and returns a corresponding ByteBufferRef of deflated data InflateByteBuffer() takes a ByteBufferRef of deflated data (previously produced by DeflateByteBuffer() ) and returns a corresponding ByteBufferRef of re-inflated data DeflateMessage() takes a MessageRef and returns a corresponding MessageRef containing only a single field of flattened data (but with the same what -code as the original Message ) -- or if the MessageRef that was passed in was already deflated, it just returns the passed-in MessageRef verbatim. InflateMessage() takes a MessageRef that was previously returned by DeflateMessage() and returns a corresponding re-inflated MessageRef containing all of the original fields again. (or if the MessageRef that was passed in wasn't a deflated Message, it just returns the passed-in MessageRef verbatim) ReadAndDeflateAndWrite() reads raw data from one DataIO , deflates it, and writes the deflated data out to another DataIO , without ever loading all of the data into RAM at once. (Useful for deflating large files) ReadAndInflateAndWrite() reads deflated data from one DataIO , inflates it, and writes the inflated data out to another DataIO , without ever loading all of the data into RAM at once. (Useful for inflating large files) Try compiling and running the mini-example-programs in muscle/html/muscle-by-example/examples/zlibutilityfunctions (enter make to compile example_*, and then run each from Terminal while looking at the corresponding .cpp file) Quick links to source code of relevant MUSCLE-by-example programs: zlibutilityfunctions/example_1_byte_buffers.cpp zlibutilityfunctions/example_2_messages.cpp","title":"muscle::ZLibUtilityFunctions class (API)"}]}