#include "system/SetupSystem.h"  // for CompleteSetupSystem
#include "message/Message.h"
#include "util/MiscUtilityFunctions.h"  // for PrintHexBytes()

using namespace muscle;

static void PrintExampleDescription()
{
   printf("\n");
   printf("In this program, we demonstrate the AddFlat()/FindFlat() idiom for adding a C++ object to a Message as a flattened-byte-buffer.\n");
   printf("\n");
}

enum {
   COMMAND_CODE_ORDER_PIZZA = 1887074913, // 'pzza' (arbitrary value generated by muscle/test/calctypecode.cpp)
   COMMAND_CODE_DELIVER_INFO
};

/** This class represents the delivery information necessary to deliver a pizza.  We'll use it to demonstrate
  * the lower-level AddFlat()/FindFlat() method to add a class's data to a Message.  Note that this method
  * is a bit more elaborate to use and maintain, but it reduces the size of the resulting Message.  I recommend
  * this approach only when minimizing storage-space is more important than keeping the codebase simple.
  */
class DeliveryInfo : public Flattenable
{
public:
   DeliveryInfo() : _zipCode(0)
   {
      // empty
   }

   DeliveryInfo(const String & name, const String & address, const String & city, const String & state, int32 zipCode)
      : _name(name), _address(address), _city(city), _state(state), _zipCode(zipCode)
   {
      // empty
   }

   // Returns false because we contain-variable-length Strings, and thus our FlattenedSize() method can return different values */
   virtual bool IsFixedSize() const {return false;}

   virtual uint32 TypeCode() const {return COMMAND_CODE_DELIVER_INFO;}

   // Returns the number of bytes our Flatten() method will write out if called on this object
   virtual uint32 FlattenedSize() const 
   {
      return sizeof(uint32)           +   // 4-byte flattened-size header
             _name.FlattenedSize()    +
             _address.FlattenedSize() +
             _city.FlattenedSize()    +
             _state.FlattenedSize()   +
             sizeof(_zipCode);
   }

   virtual void Flatten(uint8 *buffer) const
   {
      uint8 * writeTo = buffer;

      // Let's write out our flattened-size first; we can use it to do a sanity-check in Unflatten() later on
      const uint32 flattenedSize = FlattenedSize();
      muscleCopyOut(writeTo, B_HOST_TO_LENDIAN_INT32(flattenedSize));  // the muscleCopyOut() function handles potential non-aligned writes gracefully
      writeTo += sizeof(flattenedSize);
      
      _name.Flatten(writeTo);    writeTo += _name.FlattenedSize();
      _address.Flatten(writeTo); writeTo += _address.FlattenedSize();
      _city.Flatten(writeTo);    writeTo += _city.FlattenedSize();
      _state.Flatten(writeTo);   writeTo += _state.FlattenedSize();
      muscleCopyOut(writeTo, B_HOST_TO_LENDIAN_INT32(_zipCode));  // explicitly convert int32 value to little-endian (in case we are running on a big-endian machine)
   }

   virtual status_t Unflatten(const uint8 *buffer, uint32 numBytes)
   {
      if (numBytes < sizeof(uint32)) return B_BAD_DATA;

      const uint8 * readFrom = buffer;
      const uint8 * afterEnd = buffer+numBytes;   // points to the first forbidden byte after then end of our (buffer, numBytes) array

      const uint32 flattenedSize = B_LENDIAN_TO_HOST_INT32(muscleCopyIn<uint32>(readFrom));
      if (numBytes < flattenedSize) return B_BAD_DATA;  // truncated input buffer?!
      readFrom += sizeof(flattenedSize);

      MRETURN_ON_ERROR(_name.Unflatten(readFrom, numBytes));
      readFrom += _name.FlattenedSize();
      if (readFrom >= afterEnd) return B_BAD_DATA;
      
      MRETURN_ON_ERROR(_address.Unflatten(readFrom, numBytes));
      readFrom += _address.FlattenedSize();
      if (readFrom >= afterEnd) return B_BAD_DATA;

      MRETURN_ON_ERROR(_city.Unflatten(readFrom, numBytes));
      readFrom += _city.FlattenedSize();
      if (readFrom >= afterEnd) return B_BAD_DATA;

      MRETURN_ON_ERROR(_state.Unflatten(readFrom, numBytes));
      readFrom += _state.FlattenedSize();
      if (readFrom >= afterEnd) return B_BAD_DATA;

      if ((afterEnd-readFrom) < sizeof(_zipCode)) return B_BAD_DATA;
      _zipCode = B_LENDIAN_TO_HOST_INT32(muscleCopyIn<uint32>(readFrom));

      // success!
      return B_NO_ERROR;
   }

   // Print our current state to stdout
   void PrintToStream() const
   {
      printf("      name = %s\n", _name());
      printf("   address = %s\n", _address());
      printf("      city = %s\n", _city());
      printf("     state = %s\n", _state());
      printf("  ZIP code = " INT32_FORMAT_SPEC "\n", _zipCode);
   }

private:
   String _name;
   String _address;
   String _city;
   String _state;
   int32 _zipCode;
};

int main(int argc, char ** argv)
{
   CompleteSetupSystem css;

   PrintExampleDescription();

   // Let's create a Message and add some data to it
   Message orderPizzaMsg(COMMAND_CODE_ORDER_PIZZA);
   (void) orderPizzaMsg.AddInt32( "size_inches", 16);       // Error checking ommitted for clarity
   (void) orderPizzaMsg.AddBool(  "vegan",       false);    // feh!
   (void) orderPizzaMsg.AddString("toppings",    "cheese");
   (void) orderPizzaMsg.AddString("toppings",    "pepperoni");
   (void) orderPizzaMsg.AddString("toppings",    "mushrooms");
   (void) orderPizzaMsg.AddFloat( "price",       16.50f);   // in this scenario, the user gets to specify the price he wants to pay!?

   // Now let's add the user's delivery info using AddFlat() and a Flattenable DeliveryInfo class
   DeliveryInfo deliveryInfo("Hungry Joe", "20 West Montecito Ave", "Sierra Madre", "California", 91024);
   (void) orderPizzaMsg.AddFlat("delivery_info", deliveryInfo);  // calls GetMessageFromPool(), SaveToArchive(), and AddMessage() for us

   // Let's review our order
   printf("Our pizza-order Message is:\n");
   orderPizzaMsg.PrintToStream();

   // Now let's flatten the Message into a ByteBuffer and see what it looks like as flattened data
   ByteBuffer buf(orderPizzaMsg.FlattenedSize());
   orderPizzaMsg.Flatten(buf.GetBuffer());

   printf("\n");
   printf("In Flattened/serialized form, the data looks like this:\n");
   PrintHexBytes(buf);

   // Next we'll parse the flattened bytes back in to a separate Message object, just to show that we can
   Message anotherMsg;
   if (anotherMsg.Unflatten(buf.GetBuffer(), buf.GetNumBytes()).IsOK())
   {
      printf("\n");
      printf("Unflattened the ByteBuffer back into anotherMsg.  anotherMsg now contains this:\n");
      anotherMsg.PrintToStream();
   }
   else printf("Error, unable to Unflatten the byte-buffer back to anotherMsg?!\n");

   printf("\n");
   printf("ORDER SUMMARY:\n");

   // And finally we'll extract some values from (anotherMsg) programatically, just to demonstrate how
   int32 sizeInches;
   if (anotherMsg.FindInt32("size_inches", sizeInches).IsOK())
   {
      printf("The customer wants a " INT32_FORMAT_SPEC "-inch pizza.\n", sizeInches);
   }
   else printf("size_inches wasn't specified!?\n");

   // Here's a convenient way of retrieving a value from the Message, or a default value if no value is present
   const float price = anotherMsg.GetFloat("price", 19.99f);
   printf("The user expects to pay $%.02f for this pizza.\n", price);
   printf("The pizza is to be %s\n", anotherMsg.GetBool("vegan") ? "VEGAN" : "non-vegan");
   
   // And we'll list out all of the toppings (note multiple values in a single field here!)
   String nextTopping;
   for (int32 i=0; anotherMsg.FindString("toppings", i, nextTopping).IsOK(); i++)
   {
      printf("User specified topping:  %s\n", nextTopping());
   }

   // And dig out the flattened DeliveryInfo object using FindFlat()
   DeliveryInfo anotherDeliveryInfo;
   if (anotherMsg.FindFlat("delivery_info", anotherDeliveryInfo).IsOK())
   {
      printf("\n");
      printf("DELIVER TO:\n");
      anotherDeliveryInfo.PrintToStream();
   }
   else printf("No delivery_info sub-Message was present in (anotherMsg) !?\n");
 
   printf("\n");
   return 0;
}
